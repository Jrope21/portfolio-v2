import { s as safe_not_equal, n as noop, S as SvelteComponentDev, i as init, e as element, a as space, t as text, c as claim_element, b as children, d as detach$1, f as claim_text, g as attr, h as add_location, j as insert, k as append, l as binding_callbacks, m as create_slot, o as listen, p as get_slot_changes, q as get_slot_context, r as transition_in, u as add_render_callback, v as create_in_transition, w as transition_out, x as create_out_transition, y as bubble, z as mount_component, A as destroy_component, B as empty, C as group_outros, D as check_outros, E as prevent_default, F as null_to_empty, G as run_all, H as onMount, I as globals, J as set_data, K as assign, L as get_spread_update, M as setContext } from './index.ad541d75.js';
import { T as TextAnimation } from './TextAnimation.d4c3cd3c.js';

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

const CONTEXT_KEY = {};

const preload = () => ({});

/* src/components/navigation/Hamburger.svelte generated by Svelte v3.9.1 */

const file = "src/components/navigation/Hamburger.svelte";

function create_fragment(ctx) {
	var input, t0, div, t1, label, span0, t2, t3, span1;

	return {
		c: function create() {
			input = element("input");
			t0 = space();
			div = element("div");
			t1 = space();
			label = element("label");
			span0 = element("span");
			t2 = text("Navigation");
			t3 = space();
			span1 = element("span");
			this.h();
		},

		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { id: true, type: true, class: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach$1);
			t0 = claim_text(nodes, "\n");

			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach$1);
			t1 = claim_text(nodes, "\n");

			label = claim_element(nodes, "LABEL", { id: true, for: true, class: true }, false);
			var label_nodes = children(label);

			span0 = claim_element(label_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t2 = claim_text(span0_nodes, "Navigation");
			span0_nodes.forEach(detach$1);
			t3 = claim_text(label_nodes, "\n    ");

			span1 = claim_element(label_nodes, "SPAN", { class: true, title: true }, false);
			var span1_nodes = children(span1);

			span1_nodes.forEach(detach$1);
			label_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(input, "id", "toggle");
			attr(input, "type", "checkbox");
			attr(input, "class", "hide subnav-toggle hide-for-xlg svelte-1gybks5");
			add_location(input, file, 119, 0, 1893);
			attr(div, "class", "background svelte-1gybks5");
			add_location(div, file, 120, 0, 1969);
			attr(span0, "class", "show-for-sr svelte-1gybks5");
			add_location(span0, file, 122, 4, 2083);
			attr(span1, "class", "hamburger svelte-1gybks5");
			attr(span1, "title", "Navigation");
			add_location(span1, file, 123, 4, 2131);
			attr(label, "id", "nav-label");
			attr(label, "for", "toggle");
			attr(label, "class", "hide-for-xlg svelte-1gybks5");
			add_location(label, file, 121, 0, 2000);
		},

		m: function mount(target, anchor) {
			insert(target, input, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);
			insert(target, t1, anchor);
			insert(target, label, anchor);
			append(label, span0);
			append(span0, t2);
			append(label, t3);
			append(label, span1);
			ctx.label_binding(label);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(input);
				detach$1(t0);
				detach$1(div);
				detach$1(t1);
				detach$1(label);
			}

			ctx.label_binding(null);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { toggle, hamburger } = $$props;

// afterUpdate(async ()=>{
//   function hideMenu(){
//     if(toggle = true){
//       console.log('hamburger')
//       hamburger.click()
//     }
//   }
//   hideMenu();
  
// })

	const writable_props = ['toggle', 'hamburger'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Hamburger> was created with unknown prop '${key}'`);
	});

	function label_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('hamburger', hamburger = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('toggle' in $$props) $$invalidate('toggle', toggle = $$props.toggle);
		if ('hamburger' in $$props) $$invalidate('hamburger', hamburger = $$props.hamburger);
	};

	return { toggle, hamburger, label_binding };
}

class Hamburger extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["toggle", "hamburger"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.toggle === undefined && !('toggle' in props)) {
			console.warn("<Hamburger> was created without expected prop 'toggle'");
		}
		if (ctx.hamburger === undefined && !('hamburger' in props)) {
			console.warn("<Hamburger> was created without expected prop 'hamburger'");
		}
	}

	get toggle() {
		throw new Error("<Hamburger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Hamburger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hamburger() {
		throw new Error("<Hamburger>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hamburger(value) {
		throw new Error("<Hamburger>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fade(node, { delay = 0, duration = 400 }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}

/* src/components/modals/ModalTemplate.svelte generated by Svelte v3.9.1 */

const file$1 = "src/components/modals/ModalTemplate.svelte";

const get_header_slot_changes = () => ({});
const get_header_slot_context = () => ({});

function create_fragment$1(ctx) {
	var div2, div0, t0, div1, t1, div1_intro, div1_outro, div2_class_value, div2_intro, div2_outro, current, dispose;

	const header_slot_template = ctx.$$slots.header;
	const header_slot = create_slot(header_slot_template, ctx, get_header_slot_context);

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	return {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");

			if (header_slot) header_slot.c();
			t1 = space();

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			div0_nodes.forEach(detach$1);
			t0 = claim_text(div2_nodes, "\n\t");

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (header_slot) header_slot.l(div1_nodes);
			t1 = claim_text(div1_nodes, "\n\t\t");

			if (default_slot) default_slot.l(div1_nodes);
			div1_nodes.forEach(detach$1);
			div2_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "class", "modal-background svelte-19xh3ve");
			add_location(div0, file$1, 59, 4, 980);

			attr(div1, "class", "modal svelte-19xh3ve");
			add_location(div1, file$1, 60, 1, 1027);
			attr(div2, "class", div2_class_value = "center-all modal-container " + (ctx.showModal ? 'show-modal' : '') + " svelte-19xh3ve");
			add_location(div2, file$1, 58, 0, 885);
			dispose = listen(div0, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t0);
			append(div2, div1);

			if (header_slot) {
				header_slot.m(div1, null);
			}

			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (header_slot && header_slot.p && changed.$$scope) {
				header_slot.p(
					get_slot_changes(header_slot_template, ctx, changed, get_header_slot_changes),
					get_slot_context(header_slot_template, ctx, get_header_slot_context)
				);
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}

			if ((!current || changed.showModal) && div2_class_value !== (div2_class_value = "center-all modal-container " + (ctx.showModal ? 'show-modal' : '') + " svelte-19xh3ve")) {
				attr(div2, "class", div2_class_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (div1_outro) div1_outro.end(1);
				if (!div1_intro) div1_intro = create_in_transition(div1, fly, { y: -20, duration: 450, delay: 200, });
				div1_intro.start();
			});

			add_render_callback(() => {
				if (div2_outro) div2_outro.end(1);
				if (!div2_intro) div2_intro = create_in_transition(div2, fade, {});
				div2_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			transition_out(header_slot, local);
			transition_out(default_slot, local);
			if (div1_intro) div1_intro.invalidate();

			div1_outro = create_out_transition(div1, fly, { y: -20, duration: 450 });

			if (div2_intro) div2_intro.invalidate();

			div2_outro = create_out_transition(div2, fade, {});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(div2);
			}

			if (header_slot) header_slot.d(detaching);

			if (default_slot) default_slot.d(detaching);

			if (detaching) {
				if (div1_outro) div1_outro.end();
				if (div2_outro) div2_outro.end();
			}

			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	

    let { showModal } = $$props;

	const writable_props = ['showModal'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ModalTemplate> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ('showModal' in $$props) $$invalidate('showModal', showModal = $$props.showModal);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		showModal,
		click_handler,
		$$slots,
		$$scope
	};
}

class ModalTemplate extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["showModal"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.showModal === undefined && !('showModal' in props)) {
			console.warn("<ModalTemplate> was created without expected prop 'showModal'");
		}
	}

	get showModal() {
		throw new Error("<ModalTemplate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showModal(value) {
		throw new Error("<ModalTemplate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/loaders/BoxLoader.svelte generated by Svelte v3.9.1 */

const file$2 = "src/components/loaders/BoxLoader.svelte";

function create_fragment$2(ctx) {
	var div2, div0, t, div1, div2_intro, div2_outro, current;

	return {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { id: true, class: true }, false);
			var div2_nodes = children(div2);

			div0 = claim_element(div2_nodes, "DIV", { id: true, class: true }, false);
			var div0_nodes = children(div0);

			div0_nodes.forEach(detach$1);
			t = claim_text(div2_nodes, "\n  ");

			div1 = claim_element(div2_nodes, "DIV", { id: true, class: true }, false);
			var div1_nodes = children(div1);

			div1_nodes.forEach(detach$1);
			div2_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(div0, "id", "box");
			attr(div0, "class", "svelte-12rrru0");
			add_location(div0, file$2, 86, 2, 1557);
			attr(div1, "id", "hill");
			attr(div1, "class", "svelte-12rrru0");
			add_location(div1, file$2, 87, 2, 1580);
			attr(div2, "id", "loader");
			attr(div2, "class", "svelte-12rrru0");
			add_location(div2, file$2, 85, 0, 1520);
		},

		m: function mount(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t);
			append(div2, div1);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (div2_outro) div2_outro.end(1);
				if (!div2_intro) div2_intro = create_in_transition(div2, fade, {});
				div2_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			if (div2_intro) div2_intro.invalidate();

			div2_outro = create_out_transition(div2, fade, {});

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(div2);
				if (div2_outro) div2_outro.end();
			}
		}
	};
}

class BoxLoader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$2, safe_not_equal, []);
	}
}

/* src/components/modals/ContactModal.svelte generated by Svelte v3.9.1 */

const file$3 = "src/components/modals/ContactModal.svelte";

// (238:0) {#if showModal && hideModal === false}
function create_if_block(ctx) {
	var current;

	var modaltemplate = new ModalTemplate({
		props: {
		showModal: ctx.showModal,
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});
	modaltemplate.$on("click", ctx.click_handler);

	return {
		c: function create() {
			modaltemplate.$$.fragment.c();
		},

		l: function claim(nodes) {
			modaltemplate.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(modaltemplate, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var modaltemplate_changes = {};
			if (changed.showModal) modaltemplate_changes.showModal = ctx.showModal;
			if (changed.$$scope || changed.formState) modaltemplate_changes.$$scope = { changed, ctx };
			modaltemplate.$set(modaltemplate_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(modaltemplate.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(modaltemplate.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(modaltemplate, detaching);
		}
	};
}

// (265:16) {#if formState.submittingForm}
function create_if_block_3(ctx) {
	var current;

	var boxloader = new BoxLoader({ $$inline: true });

	return {
		c: function create() {
			boxloader.$$.fragment.c();
		},

		l: function claim(nodes) {
			boxloader.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(boxloader, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(boxloader.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(boxloader.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(boxloader, detaching);
		}
	};
}

// (268:16) {#if formState.formSuccess}
function create_if_block_2(ctx) {
	var h2, t, h2_intro, h2_outro, current;

	return {
		c: function create() {
			h2 = element("h2");
			t = text("SUCCESS");
			this.h();
		},

		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true }, false);
			var h2_nodes = children(h2);

			t = claim_text(h2_nodes, "SUCCESS");
			h2_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(h2, "class", "success-message svelte-1q78fvw");
			add_location(h2, file$3, 268, 20, 7659);
		},

		m: function mount(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (h2_outro) h2_outro.end(1);
				if (!h2_intro) h2_intro = create_in_transition(h2, fly, { y: 20, duration: 500, delay: 200, });
				h2_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			if (h2_intro) h2_intro.invalidate();

			h2_outro = create_out_transition(h2, fly, { y: -20, duration: 500, delay: 0, });

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(h2);
				if (h2_outro) h2_outro.end();
			}
		}
	};
}

// (276:16) {#if formState.formError}
function create_if_block_1(ctx) {
	var h2, t, h2_intro, h2_outro, current;

	return {
		c: function create() {
			h2 = element("h2");
			t = text("ERROR");
			this.h();
		},

		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", { class: true }, false);
			var h2_nodes = children(h2);

			t = claim_text(h2_nodes, "ERROR");
			h2_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(h2, "class", "success-message svelte-1q78fvw");
			add_location(h2, file$3, 276, 20, 7998);
		},

		m: function mount(target, anchor) {
			insert(target, h2, anchor);
			append(h2, t);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			add_render_callback(() => {
				if (h2_outro) h2_outro.end(1);
				if (!h2_intro) h2_intro = create_in_transition(h2, fly, { y: 20, duration: 500, delay: 200, });
				h2_intro.start();
			});

			current = true;
		},

		o: function outro(local) {
			if (h2_intro) h2_intro.invalidate();

			h2_outro = create_out_transition(h2, fly, { y: -20, duration: 500, delay: 0, });

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(h2);
				if (h2_outro) h2_outro.end();
			}
		}
	};
}

// (239:1) <ModalTemplate showModal={showModal} on:click>
function create_default_slot(ctx) {
	var div2, div1, div0, h2, t0, t1, p, t2, div0_class_value, t3, form, label0, span0, t4, t5, input0, t6, label1, span1, t7, t8, input1, t9, label2, span2, t10, t11, textarea, t12, input2, form_class_value, t13, t14, t15, current, dispose;

	var if_block0 = (ctx.formState.submittingForm) && create_if_block_3();

	var if_block1 = (ctx.formState.formSuccess) && create_if_block_2();

	var if_block2 = (ctx.formState.formError) && create_if_block_1();

	return {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			h2 = element("h2");
			t0 = text("Get In Touch");
			t1 = space();
			p = element("p");
			t2 = text("Lorem ipsum dolor sit amet consectetur, adipisicing elit. \n                        Necessitatibus suscipit quibusdam eligendi alias a, cum sit autem quas.\n                        Quibusdam minima architecto quam voluptatem. Necessitatibus, quisquam?");
			t3 = space();
			form = element("form");
			label0 = element("label");
			span0 = element("span");
			t4 = text("Name");
			t5 = space();
			input0 = element("input");
			t6 = space();
			label1 = element("label");
			span1 = element("span");
			t7 = text("Email");
			t8 = space();
			input1 = element("input");
			t9 = space();
			label2 = element("label");
			span2 = element("span");
			t10 = text("Message");
			t11 = space();
			textarea = element("textarea");
			t12 = space();
			input2 = element("input");
			t13 = space();
			if (if_block0) if_block0.c();
			t14 = space();
			if (if_block1) if_block1.c();
			t15 = space();
			if (if_block2) if_block2.c();
			this.h();
		},

		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			div1 = claim_element(div2_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			h2 = claim_element(div0_nodes, "H2", { class: true }, false);
			var h2_nodes = children(h2);

			t0 = claim_text(h2_nodes, "Get In Touch");
			h2_nodes.forEach(detach$1);
			t1 = claim_text(div0_nodes, "\n                        ");

			p = claim_element(div0_nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t2 = claim_text(p_nodes, "Lorem ipsum dolor sit amet consectetur, adipisicing elit. \n                        Necessitatibus suscipit quibusdam eligendi alias a, cum sit autem quas.\n                        Quibusdam minima architecto quam voluptatem. Necessitatibus, quisquam?");
			p_nodes.forEach(detach$1);
			div0_nodes.forEach(detach$1);
			t3 = claim_text(div1_nodes, "\n                    ");

			form = claim_element(div1_nodes, "FORM", { class: true }, false);
			var form_nodes = children(form);

			label0 = claim_element(form_nodes, "LABEL", { class: true }, false);
			var label0_nodes = children(label0);

			span0 = claim_element(label0_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t4 = claim_text(span0_nodes, "Name");
			span0_nodes.forEach(detach$1);
			t5 = claim_text(label0_nodes, "\n                                ");

			input0 = claim_element(label0_nodes, "INPUT", { name: true, type: true, class: true }, false);
			var input0_nodes = children(input0);

			input0_nodes.forEach(detach$1);
			label0_nodes.forEach(detach$1);
			t6 = claim_text(form_nodes, "\n                        ");

			label1 = claim_element(form_nodes, "LABEL", { class: true }, false);
			var label1_nodes = children(label1);

			span1 = claim_element(label1_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			t7 = claim_text(span1_nodes, "Email");
			span1_nodes.forEach(detach$1);
			t8 = claim_text(label1_nodes, "\n                            ");

			input1 = claim_element(label1_nodes, "INPUT", { required: true, name: true, type: true, class: true }, false);
			var input1_nodes = children(input1);

			input1_nodes.forEach(detach$1);
			label1_nodes.forEach(detach$1);
			t9 = claim_text(form_nodes, "\n                        ");

			label2 = claim_element(form_nodes, "LABEL", { class: true }, false);
			var label2_nodes = children(label2);

			span2 = claim_element(label2_nodes, "SPAN", { class: true }, false);
			var span2_nodes = children(span2);

			t10 = claim_text(span2_nodes, "Message");
			span2_nodes.forEach(detach$1);
			t11 = claim_text(label2_nodes, "\n                            ");

			textarea = claim_element(label2_nodes, "TEXTAREA", { name: true, rows: true, type: true, value: true, class: true }, false);
			var textarea_nodes = children(textarea);

			textarea_nodes.forEach(detach$1);
			label2_nodes.forEach(detach$1);
			t12 = claim_text(form_nodes, "\n                        ");

			input2 = claim_element(form_nodes, "INPUT", { type: true, value: true, class: true }, false);
			var input2_nodes = children(input2);

			input2_nodes.forEach(detach$1);
			form_nodes.forEach(detach$1);
			t13 = claim_text(div1_nodes, "\n                    \n                ");
			if (if_block0) if_block0.l(div1_nodes);
			t14 = claim_text(div1_nodes, "\n                ");
			if (if_block1) if_block1.l(div1_nodes);
			t15 = claim_text(div1_nodes, "\n                ");
			if (if_block2) if_block2.l(div1_nodes);
			div1_nodes.forEach(detach$1);
			div2_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(h2, "class", "svelte-1q78fvw");
			add_location(h2, file$3, 242, 24, 6269);
			attr(p, "class", "svelte-1q78fvw");
			add_location(p, file$3, 243, 24, 6315);
			attr(div0, "class", div0_class_value = "text-container " + (ctx.formState.hideFields ? 'hide-content' : '') + " " + (ctx.formState.hideFields ? 'hide-content' : '') + " svelte-1q78fvw");
			add_location(div0, file$3, 241, 20, 6126);
			attr(span0, "class", "svelte-1q78fvw");
			add_location(span0, file$3, 252, 36, 6903);
			attr(input0, "name", "name");
			attr(input0, "type", "text");
			attr(input0, "class", "svelte-1q78fvw");
			add_location(input0, file$3, 253, 32, 6953);
			attr(label0, "class", "svelte-1q78fvw");
			add_location(label0, file$3, 252, 28, 6895);
			attr(span1, "class", "svelte-1q78fvw");
			add_location(span1, file$3, 255, 32, 7054);
			input1.required = true;
			attr(input1, "name", "email");
			attr(input1, "type", "email");
			attr(input1, "class", "svelte-1q78fvw");
			add_location(input1, file$3, 256, 28, 7101);
			attr(label1, "class", "svelte-1q78fvw");
			add_location(label1, file$3, 255, 24, 7046);
			attr(span2, "class", "svelte-1q78fvw");
			add_location(span2, file$3, 258, 32, 7209);
			attr(textarea, "name", "message");
			attr(textarea, "rows", "6");
			attr(textarea, "type", "textarea");
			textarea.value = " ";
			attr(textarea, "class", "svelte-1q78fvw");
			add_location(textarea, file$3, 259, 28, 7258);
			attr(label2, "class", "svelte-1q78fvw");
			add_location(label2, file$3, 258, 24, 7201);
			attr(input2, "type", "submit");
			input2.value = "Send Message";
			attr(input2, "class", "svelte-1q78fvw");
			add_location(input2, file$3, 261, 24, 7378);
			attr(form, "class", form_class_value = "gform " + (ctx.formState.hideFields ? 'hide-content' : '') + "\n                        " + (ctx.formState.formSuccess ? 'hide-content' : '') + " svelte-1q78fvw");
			add_location(form, file$3, 247, 20, 6619);
			attr(div1, "class", "flex-container svelte-1q78fvw");
			add_location(div1, file$3, 240, 12, 6077);
			attr(div2, "class", "form-container svelte-1q78fvw");
			add_location(div2, file$3, 239, 8, 6036);
			dispose = listen(form, "submit", prevent_default(ctx.handleSubmit));
		},

		m: function mount(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, div0);
			append(div0, h2);
			append(h2, t0);
			append(div0, t1);
			append(div0, p);
			append(p, t2);
			append(div1, t3);
			append(div1, form);
			append(form, label0);
			append(label0, span0);
			append(span0, t4);
			append(label0, t5);
			append(label0, input0);
			append(form, t6);
			append(form, label1);
			append(label1, span1);
			append(span1, t7);
			append(label1, t8);
			append(label1, input1);
			append(form, t9);
			append(form, label2);
			append(label2, span2);
			append(span2, t10);
			append(label2, t11);
			append(label2, textarea);
			append(form, t12);
			append(form, input2);
			append(div1, t13);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t14);
			if (if_block1) if_block1.m(div1, null);
			append(div1, t15);
			if (if_block2) if_block2.m(div1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.formState) && div0_class_value !== (div0_class_value = "text-container " + (ctx.formState.hideFields ? 'hide-content' : '') + " " + (ctx.formState.hideFields ? 'hide-content' : '') + " svelte-1q78fvw")) {
				attr(div0, "class", div0_class_value);
			}

			if ((!current || changed.formState) && form_class_value !== (form_class_value = "gform " + (ctx.formState.hideFields ? 'hide-content' : '') + "\n                        " + (ctx.formState.formSuccess ? 'hide-content' : '') + " svelte-1q78fvw")) {
				attr(form, "class", form_class_value);
			}

			if (ctx.formState.submittingForm) {
				if (!if_block0) {
					if_block0 = create_if_block_3();
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t14);
				} else {
									transition_in(if_block0, 1);
				}
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			if (ctx.formState.formSuccess) {
				if (!if_block1) {
					if_block1 = create_if_block_2();
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t15);
				} else {
									transition_in(if_block1, 1);
				}
			} else if (if_block1) {
				group_outros();
				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});
				check_outros();
			}

			if (ctx.formState.formError) {
				if (!if_block2) {
					if_block2 = create_if_block_1();
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, null);
				} else {
									transition_in(if_block2, 1);
				}
			} else if (if_block2) {
				group_outros();
				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(div2);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			dispose();
		}
	};
}

function create_fragment$3(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.showModal && hideModal === false) && create_if_block(ctx);

	return {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.showModal && hideModal === false) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

let hideModal = false;

function buildFormSubmissionTextObj(formEventTarget, formFieldNames){
    let formData = new FormData();
    
     formFieldNames.forEach(fieldName => {
        formData.append(`${fieldName}`, `${formEventTarget[fieldName].value}`);
     });

     return formData
 }

function instance$2($$self, $$props, $$invalidate) {
	

    let { showModal } = $$props;

    let formState = {
        submittingForm: false,
        formSuccess: false,
        formError: false,
        hideFields: false
    };

    function resetForm(){
        formState.submittingForm = false; $$invalidate('formState', formState);
        formState.formSuccess = false; $$invalidate('formState', formState);
        formState.formError = false; $$invalidate('formState', formState);
        formState.hideFields = false; $$invalidate('formState', formState);
    }
    
    async function handleSubmit(e){
        formState.submittingForm = true; $$invalidate('formState', formState);
        formState.hideFields = true; $$invalidate('formState', formState);
        formState.formSuccess = false; $$invalidate('formState', formState);
        const formFieldNames = ['name', 'email', 'message']; // TODO - generate field names based on inputs
        const formTextObj = buildFormSubmissionTextObj(e.target, formFieldNames);

        setTimeout(() => { // using this block for testing animations
            formState.formError = true; $$invalidate('formState', formState);
            formState.submittingForm = false; $$invalidate('formState', formState);

            setTimeout(() => {
                resetForm();
                // formState.formError = false;
                // formState.hideFields = false;         
            }, 1500);
        }, 1000);
        // try {
        //    const response = await fetch(API_URL, settings);
        //     const data = await response.json();
        //     formState.submittingForm = false;
        //     formState.formSuccess = true;
        // } catch (e) {
        //     formState.submittingForm = false;
        //     formState.formSuccess = false;
            // formState.formError = true;
        //     console.log('error in subission', e)
        // }

        // setTimeout(() => { // TODO - set this to trigger only after modal dissapears
        //     formState.formSuccess = false;
        // }, 1500)

        setTimeout(() => { // this is the one adjusted for testing
            formState.formSuccess = false; $$invalidate('formState', formState);
        }, 2500);
    }

    // function validateEmail(event) {
    //     formState.formError = false;
    //    let textbox = event.target;
    //    if (textbox.value === '') {
    //         textbox.setCustomValidity('Required email address');
    //     } else if (textbox.validity.typeMismatch){
    //         formState.formError = true;
    //         textbox.setCustomValidity('please enter a valid email address');
    //     } else {
    //        textbox.setCustomValidity('');
    //     }
    //     return true;
    // }

	const writable_props = ['showModal'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ContactModal> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ('showModal' in $$props) $$invalidate('showModal', showModal = $$props.showModal);
	};

	return {
		showModal,
		formState,
		handleSubmit,
		click_handler
	};
}

class ContactModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$3, safe_not_equal, ["showModal"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.showModal === undefined && !('showModal' in props)) {
			console.warn("<ContactModal> was created without expected prop 'showModal'");
		}
	}

	get showModal() {
		throw new Error("<ContactModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showModal(value) {
		throw new Error("<ContactModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/navigation/Navigation.svelte generated by Svelte v3.9.1 */
const { window: window_1 } = globals;

const file$4 = "src/components/navigation/Navigation.svelte";

function create_fragment$4(ctx) {
	var scrolling = false, clear_scrolling = () => { scrolling = false; }, scrolling_timeout, header, nav, a0, p, span0, t0, t1, span1, t2, span2, t3, t4, t5, ul, li0, span3, t6, li1, a1, t7, t8, li2, a2, t9, t10, li3, a3, t11, nav_class_value, t12, current, dispose;

	add_render_callback(ctx.onwindowscroll);

	let hamburger_1_props = { toggle: toggle };
	var hamburger_1 = new Hamburger({ props: hamburger_1_props, $$inline: true });

	ctx.hamburger_1_binding(hamburger_1);

	var contactmodal = new ContactModal({
		props: { showModal: ctx.showModal },
		$$inline: true
	});
	contactmodal.$on("click", ctx.click_handler);

	return {
		c: function create() {
			header = element("header");
			nav = element("nav");
			a0 = element("a");
			p = element("p");
			span0 = element("span");
			t0 = text("<h1>");
			t1 = text("Hi There");
			span1 = element("span");
			t2 = text("!");
			span2 = element("span");
			t3 = text("</h1>");
			t4 = space();
			hamburger_1.$$.fragment.c();
			t5 = space();
			ul = element("ul");
			li0 = element("li");
			span3 = element("span");
			t6 = space();
			li1 = element("li");
			a1 = element("a");
			t7 = text("Home");
			t8 = space();
			li2 = element("li");
			a2 = element("a");
			t9 = text("About");
			t10 = space();
			li3 = element("li");
			a3 = element("a");
			t11 = text("Contact");
			t12 = space();
			contactmodal.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true }, false);
			var header_nodes = children(header);

			nav = claim_element(header_nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			a0 = claim_element(nav_nodes, "A", { href: true, class: true }, false);
			var a0_nodes = children(a0);

			p = claim_element(a0_nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			span0 = claim_element(p_nodes, "SPAN", { class: true }, false);
			var span0_nodes = children(span0);

			t0 = claim_text(span0_nodes, "<h1>");
			span0_nodes.forEach(detach$1);
			t1 = claim_text(p_nodes, "Hi There");

			span1 = claim_element(p_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			t2 = claim_text(span1_nodes, "!");
			span1_nodes.forEach(detach$1);

			span2 = claim_element(p_nodes, "SPAN", { class: true }, false);
			var span2_nodes = children(span2);

			t3 = claim_text(span2_nodes, "</h1>");
			span2_nodes.forEach(detach$1);
			p_nodes.forEach(detach$1);
			a0_nodes.forEach(detach$1);
			t4 = claim_text(nav_nodes, "\n        ");
			hamburger_1.$$.fragment.l(nav_nodes);
			t5 = claim_text(nav_nodes, "\n        ");

			ul = claim_element(nav_nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			li0 = claim_element(ul_nodes, "LI", { class: true }, false);
			var li0_nodes = children(li0);

			span3 = claim_element(li0_nodes, "SPAN", { class: true }, false);
			var span3_nodes = children(span3);

			span3_nodes.forEach(detach$1);
			li0_nodes.forEach(detach$1);
			t6 = claim_text(ul_nodes, "\n            ");

			li1 = claim_element(ul_nodes, "LI", { class: true }, false);
			var li1_nodes = children(li1);

			a1 = claim_element(li1_nodes, "A", { class: true, href: true }, false);
			var a1_nodes = children(a1);

			t7 = claim_text(a1_nodes, "Home");
			a1_nodes.forEach(detach$1);
			li1_nodes.forEach(detach$1);
			t8 = claim_text(ul_nodes, "\n            ");

			li2 = claim_element(ul_nodes, "LI", { class: true }, false);
			var li2_nodes = children(li2);

			a2 = claim_element(li2_nodes, "A", { href: true, class: true }, false);
			var a2_nodes = children(a2);

			t9 = claim_text(a2_nodes, "About");
			a2_nodes.forEach(detach$1);
			li2_nodes.forEach(detach$1);
			t10 = claim_text(ul_nodes, "\n            ");

			li3 = claim_element(ul_nodes, "LI", { class: true }, false);
			var li3_nodes = children(li3);

			a3 = claim_element(li3_nodes, "A", { href: true, class: true }, false);
			var a3_nodes = children(a3);

			t11 = claim_text(a3_nodes, "Contact");
			a3_nodes.forEach(detach$1);
			li3_nodes.forEach(detach$1);
			ul_nodes.forEach(detach$1);
			nav_nodes.forEach(detach$1);
			header_nodes.forEach(detach$1);
			t12 = claim_text(nodes, "\n\n");
			contactmodal.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			attr(span0, "class", "code svelte-pnyjmi");
			add_location(span0, file$4, 229, 16, 3965);
			attr(span1, "class", "logo-hover svelte-pnyjmi");
			add_location(span1, file$4, 229, 60, 4009);
			attr(span2, "class", "code svelte-pnyjmi");
			add_location(span2, file$4, 229, 93, 4042);
			attr(p, "class", "svelte-pnyjmi");
			add_location(p, file$4, 228, 12, 3945);
			attr(a0, "href", "/");
			attr(a0, "class", "logo svelte-pnyjmi");
			add_location(a0, file$4, 227, 8, 3907);
			attr(span3, "class", "close svelte-pnyjmi");
			add_location(span3, file$4, 234, 63, 4265);
			attr(li0, "class", "close-container svelte-pnyjmi");
			add_location(li0, file$4, 234, 12, 4214);
			attr(a1, "class", " svelte-pnyjmi");
			attr(a1, "href", "/");
			add_location(a1, file$4, 235, 16, 4314);
			attr(li1, "class", "svelte-pnyjmi");
			add_location(li1, file$4, 235, 12, 4310);
			attr(a2, "href", "/about");
			attr(a2, "class", "svelte-pnyjmi");
			add_location(a2, file$4, 236, 16, 4408);
			attr(li2, "class", "svelte-pnyjmi");
			add_location(li2, file$4, 236, 12, 4404);
			attr(a3, "href", "javascript:void(0)");
			attr(a3, "class", "svelte-pnyjmi");
			add_location(a3, file$4, 237, 16, 4499);
			attr(li3, "class", "svelte-pnyjmi");
			add_location(li3, file$4, 237, 12, 4495);
			attr(ul, "class", "navigation svelte-pnyjmi");
			add_location(ul, file$4, 233, 8, 4178);
			attr(nav, "class", nav_class_value = "" + null_to_empty((ctx.reduceNavSize ? 'scrolled container' : 'container')) + " svelte-pnyjmi");
			add_location(nav, file$4, 226, 4, 3834);
			attr(header, "class", "svelte-pnyjmi");
			add_location(header, file$4, 225, 0, 3820);

			dispose = [
				listen(window_1, "scroll", () => {
					scrolling = true;
					clearTimeout(scrolling_timeout);
					scrolling_timeout = setTimeout(clear_scrolling, 100);
					ctx.onwindowscroll();
				}),
				listen(li0, "click", ctx.togglerOff),
				listen(a1, "click", ctx.togglerOff),
				listen(a2, "click", ctx.togglerOff),
				listen(a3, "click", ctx.openModal)
			];
		},

		m: function mount(target, anchor) {
			insert(target, header, anchor);
			append(header, nav);
			append(nav, a0);
			append(a0, p);
			append(p, span0);
			append(span0, t0);
			append(p, t1);
			append(p, span1);
			append(span1, t2);
			append(p, span2);
			append(span2, t3);
			append(nav, t4);
			mount_component(hamburger_1, nav, null);
			append(nav, t5);
			append(nav, ul);
			append(ul, li0);
			append(li0, span3);
			append(ul, t6);
			append(ul, li1);
			append(li1, a1);
			append(a1, t7);
			ctx.a1_binding(a1);
			append(ul, t8);
			append(ul, li2);
			append(li2, a2);
			append(a2, t9);
			ctx.a2_binding(a2);
			append(ul, t10);
			append(ul, li3);
			append(li3, a3);
			append(a3, t11);
			insert(target, t12, anchor);
			mount_component(contactmodal, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.windowY && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window_1.pageXOffset, ctx.windowY);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			var hamburger_1_changes = {};
			if (changed.toggle) hamburger_1_changes.toggle = toggle;
			hamburger_1.$set(hamburger_1_changes);

			if ((!current || changed.reduceNavSize) && nav_class_value !== (nav_class_value = "" + null_to_empty((ctx.reduceNavSize ? 'scrolled container' : 'container')) + " svelte-pnyjmi")) {
				attr(nav, "class", nav_class_value);
			}

			var contactmodal_changes = {};
			if (changed.showModal) contactmodal_changes.showModal = ctx.showModal;
			contactmodal.$set(contactmodal_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(hamburger_1.$$.fragment, local);

			transition_in(contactmodal.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(hamburger_1.$$.fragment, local);
			transition_out(contactmodal.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(header);
			}

			ctx.hamburger_1_binding(null);

			destroy_component(hamburger_1);

			ctx.a1_binding(null);
			ctx.a2_binding(null);

			if (detaching) {
				detach$1(t12);
			}

			destroy_component(contactmodal, detaching);

			run_all(dispose);
		}
	};
}

let toggle = false;

function instance$3($$self, $$props, $$invalidate) {
	

let showModal;
let links = [];

onMount(()=>{
    links.forEach((link)=>{
        console.log(link);
    });
});

let windowY;
let hamburger;

let reduceNavSize = false;

function navSize(y){
    if(y > 75){
        $$invalidate('reduceNavSize', reduceNavSize = true);
    } else {
        $$invalidate('reduceNavSize', reduceNavSize = false);
    }
}

function togglerOff(){
    if(window.innerWidth < 820){
        hamburger ? hamburger.$$.ctx.hamburger.click() : null;
    }
}

function openModal(){
    $$invalidate('showModal', showModal = true);
}

	function onwindowscroll() {
		windowY = window_1.pageYOffset; $$invalidate('windowY', windowY);
	}

	function hamburger_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('hamburger', hamburger = $$value);
		});
	}

	function a1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			links[0] = $$value;
			$$invalidate('links', links);
		});
	}

	function a2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			links[1] = $$value;
			$$invalidate('links', links);
		});
	}

	function click_handler() {
		const $$result = showModal = false;
		$$invalidate('showModal', showModal);
		return $$result;
	}

	let headerClass;

	$$self.$$.update = ($$dirty = { windowY: 1 }) => {
		if ($$dirty.windowY) { headerClass = navSize(windowY); }
	};

	return {
		showModal,
		links,
		windowY,
		hamburger,
		reduceNavSize,
		togglerOff,
		openModal,
		onwindowscroll,
		hamburger_1_binding,
		a1_binding,
		a2_binding,
		click_handler
	};
}

class Navigation extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$4, safe_not_equal, []);
	}
}

/* src/components/footer/Footer.svelte generated by Svelte v3.9.1 */

const file$5 = "src/components/footer/Footer.svelte";

function create_fragment$5(ctx) {
	var footer, div4, div0, p0, t0, a0, t1, t2, a1, t3, t4, div3, div1, p1, t5, t6, a2, t7, div2, p2, t8, t9, a3, t10, p3, t11, current;

	var textanimation0 = new TextAnimation({
		props: { text: `Joshua.micah.roper@gmail.com` },
		$$inline: true
	});

	var textanimation1 = new TextAnimation({
		props: { text: `Download PDF` },
		$$inline: true
	});

	return {
		c: function create() {
			footer = element("footer");
			div4 = element("div");
			div0 = element("div");
			p0 = element("p");
			t0 = text("Feel free to shoot me an ");
			a0 = element("a");
			t1 = text("email");
			t2 = text(" & connect on ");
			a1 = element("a");
			t3 = text("social");
			t4 = space();
			div3 = element("div");
			div1 = element("div");
			p1 = element("p");
			t5 = text("Get In Touch!");
			t6 = space();
			a2 = element("a");
			textanimation0.$$.fragment.c();
			t7 = space();
			div2 = element("div");
			p2 = element("p");
			t8 = text("View Resume");
			t9 = space();
			a3 = element("a");
			textanimation1.$$.fragment.c();
			t10 = space();
			p3 = element("p");
			t11 = text("@ 2019 Joshua Roper Development");
			this.h();
		},

		l: function claim(nodes) {
			footer = claim_element(nodes, "FOOTER", { class: true }, false);
			var footer_nodes = children(footer);

			div4 = claim_element(footer_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div0 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			p0 = claim_element(div0_nodes, "P", { class: true }, false);
			var p0_nodes = children(p0);

			t0 = claim_text(p0_nodes, "Feel free to shoot me an ");

			a0 = claim_element(p0_nodes, "A", { href: true, class: true }, false);
			var a0_nodes = children(a0);

			t1 = claim_text(a0_nodes, "email");
			a0_nodes.forEach(detach$1);
			t2 = claim_text(p0_nodes, " & connect on ");

			a1 = claim_element(p0_nodes, "A", { href: true, target: true, class: true }, false);
			var a1_nodes = children(a1);

			t3 = claim_text(a1_nodes, "social");
			a1_nodes.forEach(detach$1);
			p0_nodes.forEach(detach$1);
			div0_nodes.forEach(detach$1);
			t4 = claim_text(div4_nodes, "\n        ");

			div3 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			div1 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			p1 = claim_element(div1_nodes, "P", { class: true }, false);
			var p1_nodes = children(p1);

			t5 = claim_text(p1_nodes, "Get In Touch!");
			p1_nodes.forEach(detach$1);
			t6 = claim_text(div1_nodes, "\n                ");

			a2 = claim_element(div1_nodes, "A", { href: true, class: true }, false);
			var a2_nodes = children(a2);

			textanimation0.$$.fragment.l(a2_nodes);
			a2_nodes.forEach(detach$1);
			div1_nodes.forEach(detach$1);
			t7 = claim_text(div3_nodes, "\n            ");

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			p2 = claim_element(div2_nodes, "P", { class: true }, false);
			var p2_nodes = children(p2);

			t8 = claim_text(p2_nodes, "View Resume");
			p2_nodes.forEach(detach$1);
			t9 = claim_text(div2_nodes, "\n                ");

			a3 = claim_element(div2_nodes, "A", { href: true, download: true, class: true }, false);
			var a3_nodes = children(a3);

			textanimation1.$$.fragment.l(a3_nodes);
			a3_nodes.forEach(detach$1);
			div2_nodes.forEach(detach$1);
			div3_nodes.forEach(detach$1);
			div4_nodes.forEach(detach$1);
			t10 = claim_text(footer_nodes, "\n    ");

			p3 = claim_element(footer_nodes, "P", { class: true }, false);
			var p3_nodes = children(p3);

			t11 = claim_text(p3_nodes, "@ 2019 Joshua Roper Development");
			p3_nodes.forEach(detach$1);
			footer_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			attr(a0, "href", "mailto:joshua.micah.toper@gmail.com");
			attr(a0, "class", "svelte-ovb0i");
			add_location(a0, file$5, 102, 41, 1672);
			attr(a1, "href", "https://www.linkedin.com/in/jr-dev");
			attr(a1, "target", "blank");
			attr(a1, "class", "svelte-ovb0i");
			add_location(a1, file$5, 102, 110, 1741);
			attr(p0, "class", "headline svelte-ovb0i");
			add_location(p0, file$5, 101, 12, 1610);
			attr(div0, "class", "left svelte-ovb0i");
			add_location(div0, file$5, 100, 8, 1579);
			attr(p1, "class", "title svelte-ovb0i");
			add_location(p1, file$5, 108, 16, 1936);
			attr(a2, "href", "mailto:joshua.micah.toper@gmail.com");
			attr(a2, "class", "svelte-ovb0i");
			add_location(a2, file$5, 111, 16, 2025);
			attr(div1, "class", "text-cta svelte-ovb0i");
			add_location(div1, file$5, 107, 12, 1897);
			attr(p2, "class", "title svelte-ovb0i");
			add_location(p2, file$5, 116, 16, 2239);
			attr(a3, "href", "./images/resume-v2Design2.pdf");
			attr(a3, "download", "");
			attr(a3, "class", "svelte-ovb0i");
			add_location(a3, file$5, 119, 16, 2326);
			attr(div2, "class", "text-cta svelte-ovb0i");
			add_location(div2, file$5, 115, 12, 2200);
			attr(div3, "class", "right svelte-ovb0i");
			add_location(div3, file$5, 106, 8, 1865);
			attr(div4, "class", "container footer-container svelte-ovb0i");
			add_location(div4, file$5, 99, 4, 1530);
			attr(p3, "class", "copyright container svelte-ovb0i");
			add_location(p3, file$5, 125, 4, 2506);
			attr(footer, "class", "svelte-ovb0i");
			add_location(footer, file$5, 98, 0, 1517);
		},

		m: function mount(target, anchor) {
			insert(target, footer, anchor);
			append(footer, div4);
			append(div4, div0);
			append(div0, p0);
			append(p0, t0);
			append(p0, a0);
			append(a0, t1);
			append(p0, t2);
			append(p0, a1);
			append(a1, t3);
			append(div4, t4);
			append(div4, div3);
			append(div3, div1);
			append(div1, p1);
			append(p1, t5);
			append(div1, t6);
			append(div1, a2);
			mount_component(textanimation0, a2, null);
			append(div3, t7);
			append(div3, div2);
			append(div2, p2);
			append(p2, t8);
			append(div2, t9);
			append(div2, a3);
			mount_component(textanimation1, a3, null);
			append(footer, t10);
			append(footer, p3);
			append(p3, t11);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(textanimation0.$$.fragment, local);

			transition_in(textanimation1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(textanimation0.$$.fragment, local);
			transition_out(textanimation1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(footer);
			}

			destroy_component(textanimation0);

			destroy_component(textanimation1);
		}
	};
}

class Footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$5, safe_not_equal, []);
	}
}

/* src/routes/_layout.svelte generated by Svelte v3.9.1 */

const file$6 = "src/routes/_layout.svelte";

function create_fragment$6(ctx) {
	var t0, div, t1, t2, current;

	var navigation = new Navigation({ $$inline: true });

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	var footer = new Footer({ $$inline: true });

	return {
		c: function create() {
			navigation.$$.fragment.c();
			t0 = space();
			div = element("div");
			t1 = space();

			if (default_slot) default_slot.c();
			t2 = space();
			footer.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			navigation.$$.fragment.l(nodes);
			t0 = claim_text(nodes, "\n");

			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach$1);
			t1 = claim_text(nodes, "\n");

			if (default_slot) default_slot.l(nodes);
			t2 = claim_text(nodes, "\n\n");
			footer.$$.fragment.l(nodes);
			this.h();
		},

		h: function hydrate() {
			attr(div, "class", "background svelte-wandjf");
			add_location(div, file$6, 19, 0, 347);
		},

		m: function mount(target, anchor) {
			mount_component(navigation, target, anchor);
			insert(target, t0, anchor);
			insert(target, div, anchor);
			insert(target, t1, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert(target, t2, anchor);
			mount_component(footer, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(navigation.$$.fragment, local);

			transition_in(default_slot, local);

			transition_in(footer.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(navigation.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(footer.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(navigation, detaching);

			if (detaching) {
				detach$1(t0);
				detach$1(div);
				detach$1(t1);
			}

			if (default_slot) default_slot.d(detaching);

			if (detaching) {
				detach$1(t2);
			}

			destroy_component(footer, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return { $$slots, $$scope };
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$6, safe_not_equal, []);
	}
}

/* src/routes/_error.svelte generated by Svelte v3.9.1 */
const { Error: Error_1 } = globals;

const file$7 = "src/routes/_error.svelte";

// (38:0) {#if dev && error.stack}
function create_if_block$1(ctx) {
	var pre, t_value = ctx.error.stack + "", t;

	return {
		c: function create() {
			pre = element("pre");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", {}, false);
			var pre_nodes = children(pre);

			t = claim_text(pre_nodes, t_value);
			pre_nodes.forEach(detach$1);
			this.h();
		},

		h: function hydrate() {
			add_location(pre, file$7, 38, 1, 443);
		},

		m: function mount(target, anchor) {
			insert(target, pre, anchor);
			append(pre, t);
		},

		p: function update(changed, ctx) {
			if ((changed.error) && t_value !== (t_value = ctx.error.stack + "")) {
				set_data(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(pre);
			}
		}
	};
}

function create_fragment$7(ctx) {
	var title_value, t0, h1, t1, t2, p, t3_value = ctx.error.message + "", t3, t4, if_block_anchor;

	document.title = title_value = ctx.status;

	var if_block = (ctx.dev && ctx.error.stack) && create_if_block$1(ctx);

	return {
		c: function create() {
			t0 = space();
			h1 = element("h1");
			t1 = text(ctx.status);
			t2 = space();
			p = element("p");
			t3 = text(t3_value);
			t4 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			t0 = claim_text(nodes, "\n\n");

			h1 = claim_element(nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t1 = claim_text(h1_nodes, ctx.status);
			h1_nodes.forEach(detach$1);
			t2 = claim_text(nodes, "\n\n");

			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t3 = claim_text(p_nodes, t3_value);
			p_nodes.forEach(detach$1);
			t4 = claim_text(nodes, "\n\n");
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr(h1, "class", "svelte-8od9u6");
			add_location(h1, file$7, 33, 0, 374);
			attr(p, "class", "svelte-8od9u6");
			add_location(p, file$7, 35, 0, 393);
		},

		m: function mount(target, anchor) {
			insert(target, t0, anchor);
			insert(target, h1, anchor);
			append(h1, t1);
			insert(target, t2, anchor);
			insert(target, p, anchor);
			append(p, t3);
			insert(target, t4, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.status) && title_value !== (title_value = ctx.status)) {
				document.title = title_value;
			}

			if (changed.status) {
				set_data(t1, ctx.status);
			}

			if ((changed.error) && t3_value !== (t3_value = ctx.error.message + "")) {
				set_data(t3, t3_value);
			}

			if (ctx.dev && ctx.error.stack) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(t0);
				detach$1(h1);
				detach$1(t2);
				detach$1(p);
				detach$1(t4);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { status, error } = $$props;

	const dev = "development" === 'development';

	const writable_props = ['status', 'error'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Error> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
	};

	return { status, error, dev };
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$7, safe_not_equal, ["status", "error"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<Error> was created without expected prop 'status'");
		}
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<Error> was created without expected prop 'error'");
		}
	}

	get status() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/node_modules/@sapper/internal/App.svelte generated by Svelte v3.9.1 */
const { Error: Error_1$1 } = globals;

// (21:1) {:else}
function create_else_block(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.level1.props
	];

	var switch_value = ctx.level1.component;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props());
	}

	return {
		c: function create() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l: function claim(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var switch_instance_changes = (changed.level1) ? get_spread_update(switch_instance_spread_levels, [
									ctx.level1.props
								]) : {};

			if (switch_value !== (switch_value = ctx.level1.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());

					switch_instance.$$.fragment.c();
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach$1(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (19:1) {#if error}
function create_if_block$2(ctx) {
	var current;

	var error_1 = new Error$1({
		props: { error: ctx.error, status: ctx.status },
		$$inline: true
	});

	return {
		c: function create() {
			error_1.$$.fragment.c();
		},

		l: function claim(nodes) {
			error_1.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(error_1, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var error_1_changes = {};
			if (changed.error) error_1_changes.error = ctx.error;
			if (changed.status) error_1_changes.status = ctx.status;
			error_1.$set(error_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(error_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(error_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(error_1, detaching);
		}
	};
}

// (18:0) <Layout segment="{segments[0]}" {...level0.props}>
function create_default_slot$1(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block$2,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.error) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach$1(if_block_anchor);
			}
		}
	};
}

function create_fragment$8(ctx) {
	var current;

	var layout_spread_levels = [
		{ segment: ctx.segments[0] },
		ctx.level0.props
	];

	let layout_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};
	for (var i = 0; i < layout_spread_levels.length; i += 1) {
		layout_props = assign(layout_props, layout_spread_levels[i]);
	}
	var layout = new Layout({ props: layout_props, $$inline: true });

	return {
		c: function create() {
			layout.$$.fragment.c();
		},

		l: function claim(nodes) {
			layout.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(layout, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var layout_changes = (changed.segments || changed.level0) ? get_spread_update(layout_spread_levels, [
									(changed.segments) && { segment: ctx.segments[0] },
			(changed.level0) && ctx.level0.props
								]) : {};
			if (changed.$$scope || changed.error || changed.status || changed.level1) layout_changes.$$scope = { changed, ctx };
			layout.$set(layout_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(layout.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(layout.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(layout, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	

	let { stores, error, status, segments, level0, level1 = null } = $$props;

	setContext(CONTEXT_KEY, stores);

	const writable_props = ['stores', 'error', 'status', 'segments', 'level0', 'level1'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('stores' in $$props) $$invalidate('stores', stores = $$props.stores);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('segments' in $$props) $$invalidate('segments', segments = $$props.segments);
		if ('level0' in $$props) $$invalidate('level0', level0 = $$props.level0);
		if ('level1' in $$props) $$invalidate('level1', level1 = $$props.level1);
	};

	return {
		stores,
		error,
		status,
		segments,
		level0,
		level1
	};
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$8, safe_not_equal, ["stores", "error", "status", "segments", "level0", "level1"]);

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.stores === undefined && !('stores' in props)) {
			console.warn("<App> was created without expected prop 'stores'");
		}
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<App> was created without expected prop 'error'");
		}
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<App> was created without expected prop 'status'");
		}
		if (ctx.segments === undefined && !('segments' in props)) {
			console.warn("<App> was created without expected prop 'segments'");
		}
		if (ctx.level0 === undefined && !('level0' in props)) {
			console.warn("<App> was created without expected prop 'level0'");
		}
	}

	get stores() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stores(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get segments() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segments(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level0() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level0(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level1() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level1(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// This file is generated by Sapper  do not edit it!

const ignore = [/^\/blog.json$/, /^\/blog\/([^\/]+?).json$/];

const components = [
	{
		js: () => import('./index.2f4eefb3.js'),
		css: ["index.2f4eefb3.css","TextAnimation.d4c3cd3c.css"]
	},
	{
		js: () => import('./about.7dada7ab.js'),
		css: ["about.7dada7ab.css"]
	},
	{
		js: () => import('./index.3511bc7d.js'),
		css: ["index.3511bc7d.css"]
	},
	{
		js: () => import('./[slug].c6fc2329.js'),
		css: ["[slug].c6fc2329.css"]
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// about.svelte
		pattern: /^\/about\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// blog/index.svelte
		pattern: /^\/blog\/?$/,
		parts: [
			{ i: 2 }
		]
	},

	{
		// blog/[slug].svelte
		pattern: /^\/blog\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 3, params: match => ({ slug: d(match[1]) }) }
		]
	}
])(decodeURIComponent);

if (typeof window !== 'undefined') {
	import('./sapper-dev-client.66640646.js').then(client => {
		client.connect(10000);
	});
}

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: writable({}),
	preloading: writable(null),
	session: writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;
function set_prefetching(href, promise) {
	prefetching = { href, promise };
}

let target;
function set_target(element) {
	target = element;
}

let uid = 1;
function set_uid(n) {
	uid = n;
}

let cid;
function set_cid(n) {
	cid = n;
}

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function handle_error(url) {
	const { host, pathname, search } = location;
	const { session, preloaded, status, error } = initial_data;

	if (!root_preloaded) {
		root_preloaded = preloaded && preloaded[0];
	}

	const props = {
		error,
		status,
		session,
		level0: {
			props: root_preloaded
		},
		level1: {
			props: {
				status,
				error
			},
			component: Error$1
		},
		segments: preloaded

	};
	const query = extract_query(search);
	render(null, [], props, { host, path: pathname, query, params: {} });
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};

		// first load  remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary  once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

function prefetch(href) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		if (!prefetching || href !== prefetching.href) {
			set_prefetching(href, hydrate_target(target));
		}

		return prefetching.promise;
	}
}

function start(opts

) {
	if ('scrollRestoration' in _history) {
		_history.scrollRestoration = 'manual';
	}

	set_target(opts.target);

	addEventListener('click', handle_click);
	addEventListener('popstate', handle_popstate);

	// prefetch
	addEventListener('touchstart', trigger_prefetch);
	addEventListener('mousemove', handle_mousemove);

	return Promise.resolve().then(() => {
		const { hash, href } = location;

		_history.replaceState({ id: uid }, '', href);

		const url = new URL(location.href);

		if (initial_data.error) return handle_error();

		const target = select_target(url);
		if (target) return navigate(target, uid, true, hash);
	});
}

let mousemove_timeout;

function handle_mousemove(event) {
	clearTimeout(mousemove_timeout);
	mousemove_timeout = setTimeout(() => {
		trigger_prefetch(event);
	}, 20);
}

function trigger_prefetch(event) {
	const a = find_anchor(event.target);
	if (!a || a.rel !== 'prefetch') return;

	prefetch(a.href);
}

function handle_click(event) {
	// Adapted from https://github.com/visionmedia/page.js
	// MIT license https://github.com/visionmedia/page.js#license
	if (which(event) !== 1) return;
	if (event.metaKey || event.ctrlKey || event.shiftKey) return;
	if (event.defaultPrevented) return;

	const a = find_anchor(event.target);
	if (!a) return;

	if (!a.href) return;

	// check if link is inside an svg
	// in this case, both href and target are always inside an object
	const svg = typeof a.href === 'object' && a.href.constructor.name === 'SVGAnimatedString';
	const href = String(svg ? (a).href.baseVal : a.href);

	if (href === location.href) {
		if (!location.hash) event.preventDefault();
		return;
	}

	// Ignore if tag has
	// 1. 'download' attribute
	// 2. rel='external' attribute
	if (a.hasAttribute('download') || a.getAttribute('rel') === 'external') return;

	// Ignore if <a> has a target
	if (svg ? (a).target.baseVal : a.target) return;

	const url = new URL(href);

	// Don't handle hash changes
	if (url.pathname === location.pathname && url.search === location.search) return;

	const target = select_target(url);
	if (target) {
		const noscroll = a.hasAttribute('sapper-noscroll');
		navigate(target, null, noscroll, url.hash);
		event.preventDefault();
		_history.pushState({ id: cid }, '', url.href);
	}
}

function which(event) {
	return event.which === null ? event.button : event.which;
}

function find_anchor(node) {
	while (node && node.nodeName.toUpperCase() !== 'A') node = node.parentNode; // SVG <a> elements have a lowercase name
	return node;
}

function handle_popstate(event) {
	scroll_history[cid] = scroll_state();

	if (event.state) {
		const url = new URL(location.href);
		const target = select_target(url);
		if (target) {
			navigate(target, event.state.id);
		} else {
			location.href = location.href;
		}
	} else {
		// hashchange
		set_uid(uid + 1);
		set_cid(uid);
		_history.replaceState({ id: cid }, '', location.href);
	}
}

start({
	target: document.querySelector('#sapper')
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpZW50LmQyOTQzODUzLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3N0b3JlL2luZGV4Lm1qcyIsIi4uLy4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9pbnRlcm5hbC9zaGFyZWQubWpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9IYW1idXJnZXIuc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9lYXNpbmcvaW5kZXgubWpzIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS90cmFuc2l0aW9uL2luZGV4Lm1qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL21vZGFscy9Nb2RhbFRlbXBsYXRlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL21vZGFscy9Db250YWN0TW9kYWwuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9OYXZpZ2F0aW9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2Zvb3Rlci9Gb290ZXIuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fZXJyb3Iuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL25vZGVfbW9kdWxlcy9Ac2FwcGVyL2ludGVybmFsL0FwcC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvbm9kZV9tb2R1bGVzL0BzYXBwZXIvaW50ZXJuYWwvbWFuaWZlc3QtY2xpZW50Lm1qcyIsIi4uLy4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9hcHAubWpzIiwiLi4vLi4vLi4vc3JjL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzYWZlX25vdF9lcXVhbCwgbm9vcCwgcnVuX2FsbCwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5leHBvcnQgeyBnZXRfc3RvcmVfdmFsdWUgYXMgZ2V0IH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHZhbHVlIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXJ9c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9uc1xuICovXG5mdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlLFxuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGBXcml0YWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgYm90aCB1cGRhdGluZyBhbmQgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKiBAcGFyYW0geyo9fXZhbHVlIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI9fXN0YXJ0IHN0YXJ0IGFuZCBzdG9wIG5vdGlmaWNhdGlvbnMgZm9yIHN1YnNjcmlwdGlvbnNcbiAqL1xuZnVuY3Rpb24gd3JpdGFibGUodmFsdWUsIHN0YXJ0ID0gbm9vcCkge1xuICAgIGxldCBzdG9wO1xuICAgIGNvbnN0IHN1YnNjcmliZXJzID0gW107XG4gICAgZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuICAgICAgICBpZiAoc2FmZV9ub3RfZXF1YWwodmFsdWUsIG5ld192YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3X3ZhbHVlO1xuICAgICAgICAgICAgaWYgKHN0b3ApIHsgLy8gc3RvcmUgaXMgcmVhZHlcbiAgICAgICAgICAgICAgICBjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHNbMV0oKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZS5wdXNoKHMsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bl9xdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG4gICAgICAgIHNldChmbih2YWx1ZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJzY3JpYmUocnVuLCBpbnZhbGlkYXRlID0gbm9vcCkge1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG4gICAgICAgIHN1YnNjcmliZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdGFydChzZXQpIHx8IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnMuaW5kZXhPZihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICBzdG9wID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2V0LCB1cGRhdGUsIHN1YnNjcmliZSB9O1xufVxuLyoqXG4gKiBEZXJpdmVkIHZhbHVlIHN0b3JlIGJ5IHN5bmNocm9uaXppbmcgb25lIG9yIG1vcmUgcmVhZGFibGUgc3RvcmVzIGFuZFxuICogYXBwbHlpbmcgYW4gYWdncmVnYXRpb24gZnVuY3Rpb24gb3ZlciBpdHMgaW5wdXQgdmFsdWVzLlxuICogQHBhcmFtIHtTdG9yZXN9IHN0b3JlcyBpbnB1dCBzdG9yZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oU3RvcmVzPSwgZnVuY3Rpb24oKik9KToqfWZuIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgYWdncmVnYXRlcyB0aGUgdmFsdWVzXG4gKiBAcGFyYW0geyo9fWluaXRpYWxfdmFsdWUgd2hlbiB1c2VkIGFzeW5jaHJvbm91c2x5XG4gKi9cbmZ1bmN0aW9uIGRlcml2ZWQoc3RvcmVzLCBmbiwgaW5pdGlhbF92YWx1ZSkge1xuICAgIGNvbnN0IHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG4gICAgY29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlXG4gICAgICAgID8gW3N0b3Jlc11cbiAgICAgICAgOiBzdG9yZXM7XG4gICAgY29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG4gICAgcmV0dXJuIHJlYWRhYmxlKGluaXRpYWxfdmFsdWUsIChzZXQpID0+IHtcbiAgICAgICAgbGV0IGluaXRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSAwO1xuICAgICAgICBsZXQgY2xlYW51cCA9IG5vb3A7XG4gICAgICAgIGNvbnN0IHN5bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0KTtcbiAgICAgICAgICAgIGlmIChhdXRvKSB7XG4gICAgICAgICAgICAgICAgc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwID0gaXNfZnVuY3Rpb24ocmVzdWx0KSA/IHJlc3VsdCA6IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlcnMgPSBzdG9yZXNfYXJyYXkubWFwKChzdG9yZSwgaSkgPT4gc3RvcmUuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICBwZW5kaW5nICY9IH4oMSA8PCBpKTtcbiAgICAgICAgICAgIGlmIChpbml0ZWQpIHtcbiAgICAgICAgICAgICAgICBzeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgIHBlbmRpbmcgfD0gKDEgPDwgaSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaW5pdGVkID0gdHJ1ZTtcbiAgICAgICAgc3luYygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodW5zdWJzY3JpYmVycyk7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGRlcml2ZWQsIHJlYWRhYmxlLCB3cml0YWJsZSB9O1xuIiwiaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuXG5leHBvcnQgY29uc3QgQ09OVEVYVF9LRVkgPSB7fTtcblxuZXhwb3J0IGNvbnN0IHByZWxvYWQgPSAoKSA9PiAoe30pOyIsIjxzY3JpcHQ+XG5pbXBvcnQgeyBvbk1vdW50LCBhZnRlclVwZGF0ZSwgdGljayAgfSBmcm9tICdzdmVsdGUnO1xuXG5leHBvcnQgbGV0IHRvZ2dsZTtcbmV4cG9ydCBsZXQgaGFtYnVyZ2VyO1xuXG4vLyBhZnRlclVwZGF0ZShhc3luYyAoKT0+e1xuLy8gICBmdW5jdGlvbiBoaWRlTWVudSgpe1xuLy8gICAgIGlmKHRvZ2dsZSA9IHRydWUpe1xuLy8gICAgICAgY29uc29sZS5sb2coJ2hhbWJ1cmdlcicpXG4vLyAgICAgICBoYW1idXJnZXIuY2xpY2soKVxuLy8gICAgIH1cbi8vICAgfVxuLy8gICBoaWRlTWVudSgpO1xuICBcbi8vIH0pXG5cblxuXG5cblxuXG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG5Aa2V5ZnJhbWVzIGxlYXZlU2NyZWVuIHtcbiAgMTAwJXtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoOTk5OXB4KVxuICB9XG59XG5cbiN0b2dnbGUge1xuICBkaXNwbGF5OiBub25lO1xufVxuXG4uaGFtYnVyZ2VyIHtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1ldmVubHk7XG4gIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrO1xuICB3aWR0aDogMjRweDtcbiAgaGVpZ2h0OiAyMnB4O1xuICB0cmFuc2l0aW9uOiB3aWR0aCAuNDVzIGN1YmljLWJlemllcigwLjg1LCAwLjA4LCAwLjA4LCAwLjk5KTtcbn1cblxuLmhhbWJ1cmdlcjo6YmVmb3JlIHtcbiAgY29udGVudDogJyc7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBib3JkZXItYm90dG9tOiAycHggc29saWQgYmxhY2s7XG4gIHdpZHRoOiAxOHB4O1xuICB0cmFuc2l0aW9uOiB3aWR0aCAuNDVzIGN1YmljLWJlemllcigwLjg1LCAwLjA4LCAwLjA4LCAwLjk5KTtcbn1cblxuLmhhbWJ1cmdlcjo6YWZ0ZXIge1xuICBjb250ZW50OiAnJztcbiAgZGlzcGxheTogYmxvY2s7XG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjaztcbiAgd2lkdGg6IDMycHg7XG59XG5cbi5iYWNrZ3JvdW5kIHtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjMxOSk7XG4gIG9wYWNpdHk6IDA7XG4gIHdpZHRoOiAxMDB2dztcbiAgaGVpZ2h0OiAxMDB2aDtcbiAgcG9zaXRpb246IGZpeGVkO1xuICAvKiB6LWluZGV4OiAtMTAwOyAqL1xuICBib3R0b206IDA7XG4gIGxlZnQ6IDA7XG4gIHotaW5kZXg6IDE7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgLjM1cyBlYXNlLWluO1xuICBhbmltYXRpb246IC4wMXMgZWFzZS1pbiAuMzVzIDEgbGVhdmVTY3JlZW4gZm9yd2FyZHM7XG59XG5cbiN0b2dnbGU6aG92ZXIgKyAuYmFja2dyb3VuZCArIGxhYmVsID4gLmhhbWJ1cmdlciB7XG4gIHdpZHRoOiAzMnB4O1xufVxuXG4jdG9nZ2xlOmNoZWNrZWQgKyAuYmFja2dyb3VuZCArIGxhYmVsID4gLmhhbWJ1cmdlciB7XG4gIHdpZHRoOiAzMnB4O1xufVxuXG4jdG9nZ2xlOmhvdmVyICsgLmJhY2tncm91bmQgKyBsYWJlbCA+IC5oYW1idXJnZXI6OmJlZm9yZSB7XG4gIHdpZHRoOiAzMnB4O1xufVxuXG4jdG9nZ2xlOmNoZWNrZWQgKyAuYmFja2dyb3VuZCArIGxhYmVsID4gLmhhbWJ1cmdlcjo6YmVmb3JlIHtcbiAgd2lkdGg6IDMycHg7XG59XG5cbiN0b2dnbGU6Y2hlY2tlZCArIC5iYWNrZ3JvdW5kIHtcbiAgb3BhY2l0eTogMTtcbiAgei1pbmRleDogMTtcbiAgYW5pbWF0aW9uOiB1bnNldDtcbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSl7XG4gIGxhYmVsIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG59XG5cbi5zaG93LWZvci1zciB7XG4gIGJvcmRlcjogMDtcbiAgY2xpcDogcmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpO1xuICBjbGlwLXBhdGg6IGluc2V0KDUwJSk7XG4gIGhlaWdodDogMXB4O1xuICBtYXJnaW46IC0xcHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIHBhZGRpbmc6IDA7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IDFweDtcbiAgd29yZC13cmFwOiBub3JtYWwgIWltcG9ydGFudDtcbn1cblxuPC9zdHlsZT5cblxuPGlucHV0IGlkPVwidG9nZ2xlXCIgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJoaWRlIHN1Ym5hdi10b2dnbGUgaGlkZS1mb3IteGxnXCI+XG48ZGl2IGNsYXNzPVwiYmFja2dyb3VuZFwiPjwvZGl2PlxuPGxhYmVsIGlkPVwibmF2LWxhYmVsXCIgYmluZDp0aGlzPXtoYW1idXJnZXJ9IGZvcj1cInRvZ2dsZVwiIGNsYXNzPVwiaGlkZS1mb3IteGxnXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJzaG93LWZvci1zclwiPk5hdmlnYXRpb248L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJoYW1idXJnZXJcIiB0aXRsZT1cIk5hdmlnYXRpb25cIj4gPC9zcGFuPlxuPC9sYWJlbD4iLCJleHBvcnQgeyBpZGVudGl0eSBhcyBsaW5lYXIgfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbi8qXG5BZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsXG5EaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vbWF0dGRlc2wvZWFzZXMvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuKi9cbmZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykpO1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKTtcbn1cbmZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG59XG5mdW5jdGlvbiBiYWNrT3V0KHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gLS10ICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbn1cbmZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XG4gICAgY29uc3QgYSA9IDQuMCAvIDExLjA7XG4gICAgY29uc3QgYiA9IDguMCAvIDExLjA7XG4gICAgY29uc3QgYyA9IDkuMCAvIDEwLjA7XG4gICAgY29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbiAgICBjb25zdCBjYiA9IDM1NDQyLjAgLyAxODA1LjA7XG4gICAgY29uc3QgY2MgPSAxNjA2MS4wIC8gMTgwNS4wO1xuICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgcmV0dXJuIHQgPCBhXG4gICAgICAgID8gNy41NjI1ICogdDJcbiAgICAgICAgOiB0IDwgYlxuICAgICAgICAgICAgPyA5LjA3NSAqIHQyIC0gOS45ICogdCArIDMuNFxuICAgICAgICAgICAgOiB0IDwgY1xuICAgICAgICAgICAgICAgID8gY2EgKiB0MiAtIGNiICogdCArIGNjXG4gICAgICAgICAgICAgICAgOiAxMC44ICogdCAqIHQgLSAyMC41MiAqIHQgKyAxMC43Mjtcbn1cbmZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/IDAuNSAqICgxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCAqIDIuMCkpXG4gICAgICAgIDogMC41ICogYm91bmNlT3V0KHQgKiAyLjAgLSAxLjApICsgMC41O1xufVxuZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICAgIHJldHVybiAxLjAgLSBib3VuY2VPdXQoMS4wIC0gdCk7XG59XG5mdW5jdGlvbiBjaXJjSW5PdXQodCkge1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSk7XG4gICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKTtcbn1cbmZ1bmN0aW9uIGNpcmNJbih0KSB7XG4gICAgcmV0dXJuIDEuMCAtIE1hdGguc3FydCgxLjAgLSB0ICogdCk7XG59XG5mdW5jdGlvbiBjaXJjT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cbmZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNC4wICogdCAqIHQgKiB0IDogMC41ICogTWF0aC5wb3coMi4wICogdCAtIDIuMCwgMy4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIGN1YmljSW4odCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gICAgY29uc3QgZiA9IHQgLSAxLjA7XG4gICAgcmV0dXJuIGYgKiBmICogZiArIDEuMDtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKlxuICAgICAgICAgICAgTWF0aC5zaW4oKCgrMTMuMCAqIE1hdGguUEkpIC8gMikgKiAyLjAgKiB0KSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIDEwLjAgKiAoMi4wICogdCAtIDEuMCkpXG4gICAgICAgIDogMC41ICpcbiAgICAgICAgICAgIE1hdGguc2luKCgoLTEzLjAgKiBNYXRoLlBJKSAvIDIpICogKDIuMCAqIHQgLSAxLjAgKyAxLjApKSAqXG4gICAgICAgICAgICBNYXRoLnBvdygyLjAsIC0xMC4wICogKDIuMCAqIHQgLSAxLjApKSArXG4gICAgICAgICAgICAxLjA7XG59XG5mdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBNYXRoLnNpbigoMTMuMCAqIHQgKiBNYXRoLlBJKSAvIDIpICogTWF0aC5wb3coMi4wLCAxMC4wICogKHQgLSAxLjApKTtcbn1cbmZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAoTWF0aC5zaW4oKC0xMy4wICogKHQgKyAxLjApICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KSArIDEuMCk7XG59XG5mdW5jdGlvbiBleHBvSW5PdXQodCkge1xuICAgIHJldHVybiB0ID09PSAwLjAgfHwgdCA9PT0gMS4wXG4gICAgICAgID8gdFxuICAgICAgICA6IHQgPCAwLjVcbiAgICAgICAgICAgID8gKzAuNSAqIE1hdGgucG93KDIuMCwgMjAuMCAqIHQgLSAxMC4wKVxuICAgICAgICAgICAgOiAtMC41ICogTWF0aC5wb3coMi4wLCAxMC4wIC0gdCAqIDIwLjApICsgMS4wO1xufVxuZnVuY3Rpb24gZXhwb0luKHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMC4wID8gdCA6IE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5mdW5jdGlvbiBleHBvT3V0KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMS4wID8gdCA6IDEuMCAtIE1hdGgucG93KDIuMCwgLTEwLjAgKiB0KTtcbn1cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gICAgdCAvPSAwLjU7XG4gICAgaWYgKHQgPCAxKVxuICAgICAgICByZXR1cm4gMC41ICogdCAqIHQ7XG4gICAgdC0tO1xuICAgIHJldHVybiAtMC41ICogKHQgKiAodCAtIDIpIC0gMSk7XG59XG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICAgIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICAgIHJldHVybiAtdCAqICh0IC0gMi4wKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gKzguMCAqIE1hdGgucG93KHQsIDQuMClcbiAgICAgICAgOiAtOC4wICogTWF0aC5wb3codCAtIDEuMCwgNC4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIHF1YXJ0SW4odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0LCA0LjApO1xufVxuZnVuY3Rpb24gcXVhcnRPdXQodCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0IC0gMS4wLCAzLjApICogKDEuMCAtIHQpICsgMS4wO1xufVxuZnVuY3Rpb24gcXVpbnRJbk91dCh0KSB7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0O1xuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMik7XG59XG5mdW5jdGlvbiBxdWludEluKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBxdWludE91dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xufVxuZnVuY3Rpb24gc2luZUluT3V0KHQpIHtcbiAgICByZXR1cm4gLTAuNSAqIChNYXRoLmNvcyhNYXRoLlBJICogdCkgLSAxKTtcbn1cbmZ1bmN0aW9uIHNpbmVJbih0KSB7XG4gICAgY29uc3QgdiA9IE1hdGguY29zKHQgKiBNYXRoLlBJICogMC41KTtcbiAgICBpZiAoTWF0aC5hYnModikgPCAxZS0xNClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gMSAtIHY7XG59XG5mdW5jdGlvbiBzaW5lT3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKHQgKiBNYXRoLlBJKSAvIDIpO1xufVxuXG5leHBvcnQgeyBiYWNrSW4sIGJhY2tJbk91dCwgYmFja091dCwgYm91bmNlSW4sIGJvdW5jZUluT3V0LCBib3VuY2VPdXQsIGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0LCBjdWJpY0luLCBjdWJpY0luT3V0LCBjdWJpY091dCwgZWxhc3RpY0luLCBlbGFzdGljSW5PdXQsIGVsYXN0aWNPdXQsIGV4cG9JbiwgZXhwb0luT3V0LCBleHBvT3V0LCBxdWFkSW4sIHF1YWRJbk91dCwgcXVhZE91dCwgcXVhcnRJbiwgcXVhcnRJbk91dCwgcXVhcnRPdXQsIHF1aW50SW4sIHF1aW50SW5PdXQsIHF1aW50T3V0LCBzaW5lSW4sIHNpbmVJbk91dCwgc2luZU91dCB9O1xuIiwiaW1wb3J0IHsgY3ViaWNPdXQsIGN1YmljSW5PdXQgfSBmcm9tICcuLi9lYXNpbmcnO1xuaW1wb3J0IHsgaXNfZnVuY3Rpb24sIGFzc2lnbiB9IGZyb20gJy4uL2ludGVybmFsJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG5mdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCB9KSB7XG4gICAgY29uc3QgbyA9ICtnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9wYWNpdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBjc3M6IHQgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuICAgIH07XG59XG5mdW5jdGlvbiBmbHkobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBvZCA9IHRhcmdldF9vcGFjaXR5ICogKDEgLSBvcGFjaXR5KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7KDEgLSB0KSAqIHh9cHgsICR7KDEgLSB0KSAqIHl9cHgpO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCB9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUZsb2F0KHN0eWxlLmhlaWdodCk7XG4gICAgY29uc3QgcGFkZGluZ190b3AgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApO1xuICAgIGNvbnN0IHBhZGRpbmdfYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICBjb25zdCBtYXJnaW5fdG9wID0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Ub3ApO1xuICAgIGNvbnN0IG1hcmdpbl9ib3R0b20gPSBwYXJzZUZsb2F0KHN0eWxlLm1hcmdpbkJvdHRvbSk7XG4gICAgY29uc3QgYm9yZGVyX3RvcF93aWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpO1xuICAgIGNvbnN0IGJvcmRlcl9ib3R0b21fd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiB0ID0+IGBvdmVyZmxvdzogaGlkZGVuO2AgK1xuICAgICAgICAgICAgYG9wYWNpdHk6ICR7TWF0aC5taW4odCAqIDIwLCAxKSAqIG9wYWNpdHl9O2AgK1xuICAgICAgICAgICAgYGhlaWdodDogJHt0ICogaGVpZ2h0fXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctdG9wOiAke3QgKiBwYWRkaW5nX3RvcH1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLWJvdHRvbTogJHt0ICogcGFkZGluZ19ib3R0b219cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLXRvcDogJHt0ICogbWFyZ2luX3RvcH1weDtgICtcbiAgICAgICAgICAgIGBtYXJnaW4tYm90dG9tOiAke3QgKiBtYXJnaW5fYm90dG9tfXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci10b3Atd2lkdGg6ICR7dCAqIGJvcmRlcl90b3Bfd2lkdGh9cHg7YCArXG4gICAgICAgICAgICBgYm9yZGVyLWJvdHRvbS13aWR0aDogJHt0ICogYm9yZGVyX2JvdHRvbV93aWR0aH1weDtgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNjYWxlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHN0YXJ0ID0gMCwgb3BhY2l0eSA9IDAgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSAoc2QgKiB1KX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfVxuXHRcdGBcbiAgICB9O1xufVxuZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY0luT3V0IH0pIHtcbiAgICBjb25zdCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gODAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAodCwgdSkgPT4gYHN0cm9rZS1kYXNoYXJyYXk6ICR7dCAqIGxlbn0gJHt1ICogbGVufWBcbiAgICB9O1xufVxuZnVuY3Rpb24gY3Jvc3NmYWRlKF9hKSB7XG4gICAgdmFyIHsgZmFsbGJhY2sgfSA9IF9hLCBkZWZhdWx0cyA9IF9fcmVzdChfYSwgW1wiZmFsbGJhY2tcIl0pO1xuICAgIGNvbnN0IHRvX3JlY2VpdmUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdG9fc2VuZCA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBjcm9zc2ZhZGUoZnJvbSwgbm9kZSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMzAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBhc3NpZ24oYXNzaWduKHt9LCBkZWZhdWx0cyksIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRvID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgZHggPSBmcm9tLmxlZnQgLSB0by5sZWZ0O1xuICAgICAgICBjb25zdCBkeSA9IGZyb20udG9wIC0gdG8udG9wO1xuICAgICAgICBjb25zdCBkdyA9IGZyb20ud2lkdGggLyB0by53aWR0aDtcbiAgICAgICAgY29uc3QgZGggPSBmcm9tLmhlaWdodCAvIHRvLmhlaWdodDtcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdFx0b3BhY2l0eTogJHt0ICogb3BhY2l0eX07XG5cdFx0XHRcdHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0O1xuXHRcdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHt1ICogZHh9cHgsJHt1ICogZHl9cHgpIHNjYWxlKCR7dCArICgxIC0gdCkgKiBkd30sICR7dCArICgxIC0gdCkgKiBkaH0pO1xuXHRcdFx0YFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uKGl0ZW1zLCBjb3VudGVycGFydHMsIGludHJvKSB7XG4gICAgICAgIHJldHVybiAobm9kZSwgcGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpdGVtcy5zZXQocGFyYW1zLmtleSwge1xuICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlY3QgfSA9IGNvdW50ZXJwYXJ0cy5nZXQocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJwYXJ0cy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc2ZhZGUocmVjdCwgbm9kZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgaXMgZGlzYXBwZWFyaW5nIGFsdG9nZXRoZXJcbiAgICAgICAgICAgICAgICAvLyAoaS5lLiB3YXNuJ3QgY2xhaW1lZCBieSB0aGUgb3RoZXIgbGlzdClcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gc3VwcGx5IGFuIG91dHJvXG4gICAgICAgICAgICAgICAgaXRlbXMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjayAmJiBmYWxsYmFjayhub2RlLCBwYXJhbXMsIGludHJvKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHRyYW5zaXRpb24odG9fc2VuZCwgdG9fcmVjZWl2ZSwgZmFsc2UpLFxuICAgICAgICB0cmFuc2l0aW9uKHRvX3JlY2VpdmUsIHRvX3NlbmQsIHRydWUpXG4gICAgXTtcbn1cblxuZXhwb3J0IHsgY3Jvc3NmYWRlLCBkcmF3LCBmYWRlLCBmbHksIHNjYWxlLCBzbGlkZSB9O1xuIiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xuICAgIGltcG9ydCB7IGZhZGUsIGZseSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcblxuICAgIGV4cG9ydCBsZXQgc2hvd01vZGFsXG4gICAgXG4gICAgY29uc3QgZGlzcGF0Y2ggPSBjcmVhdGVFdmVudERpc3BhdGNoZXIoKTtcbiAgICBcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG5cbiAgICAubW9kYWwtY29udGFpbmVye1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG5cdFx0dG9wOiAwO1xuXHRcdGxlZnQ6IDA7XG5cdFx0d2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgei1pbmRleDogNTA7XG4gICAgfVxuXHQubW9kYWwtYmFja2dyb3VuZCB7XG5cdFx0cG9zaXRpb246IGZpeGVkO1xuXHRcdHRvcDogMDtcblx0XHRsZWZ0OiAwO1xuXHRcdHdpZHRoOiAxMDAlO1xuXHRcdGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjMpO1xuXHR9XG5cblx0LmNvbnRhaW5lcntcblx0XHR3aWR0aDogMTAwJTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdH1cblxuXHQubW9kYWwge1xuICAgICAgICB3aWR0aDogY2FsYygxMDB2dyAtIDRlbSk7XG4gICAgICAgIHdpZHRoOiA4MCU7XG5cdFx0bWF4LXdpZHRoOiA2NTBweDtcblx0XHRtYXgtaGVpZ2h0OiA5MHZoO1xuXHRcdG92ZXJmbG93OiBhdXRvO1xuXHRcdGJvcmRlci1yYWRpdXM6IDEwcmVtO1xuICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogNTA7XG4gICAgfVxuICAgIFxuXHRAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKXtcblx0XHQubW9kYWwge1xuXHRcdFx0bWF4LWhlaWdodDogNDUwcHg7XG5cdFx0XHR3aWR0aDogNzAlO1xuXHRcdH1cbiAgICB9XG4gICAgXG5cdGJ1dHRvbiB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG4gICAgfSAgIFxuICAgIFxuPC9zdHlsZT5cblxuPGRpdiBjbGFzcz0nY2VudGVyLWFsbCBtb2RhbC1jb250YWluZXIge3Nob3dNb2RhbCA/ICdzaG93LW1vZGFsJyA6ICcnfScgaW46ZmFkZSBvdXQ6ZmFkZSA+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tncm91bmRcIiBvbjpjbGljaz48L2Rpdj5cblx0PGRpdiBjbGFzcz0nbW9kYWwnIGluOmZseT1cInt7IHk6IC0yMCwgZHVyYXRpb246IDQ1MCwgZGVsYXk6IDIwMCwgfX1cIiBvdXQ6Zmx5PVwie3sgeTogLTIwLCBkdXJhdGlvbjogNDUwIH19XCI+XG5cdFx0PHNsb3QgbmFtZT0naGVhZGVyJz48L3Nsb3Q+XG5cdFx0PHNsb3Q+PC9zbG90PlxuXHQ8L2Rpdj5cbjwvZGl2PiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgZmFkZSwgZmx5IH0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG5cdGltcG9ydCBNb2RhbFRlbXBsYXRlIGZyb20gJy4vTW9kYWxUZW1wbGF0ZS5zdmVsdGUnO1xuICAgIGltcG9ydCBCb3hMb2FkZXIgZnJvbSAnLi4vbG9hZGVycy9Cb3hMb2FkZXIuc3ZlbHRlJztcblxuICAgIGV4cG9ydCBsZXQgc2hvd01vZGFsO1xuICAgIGxldCBoaWRlTW9kYWwgPSBmYWxzZTtcblxuICAgIGxldCBmb3JtU3RhdGUgPSB7XG4gICAgICAgIHN1Ym1pdHRpbmdGb3JtOiBmYWxzZSxcbiAgICAgICAgZm9ybVN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBmb3JtRXJyb3I6IGZhbHNlLFxuICAgICAgICBoaWRlRmllbGRzOiBmYWxzZVxuICAgIH1cblxuICAgIGxldCBkZWZhdWx0Rm9ybVN0YXRlID0gZm9ybVN0YXRlO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRGb3JtKCl7XG4gICAgICAgIGZvcm1TdGF0ZS5zdWJtaXR0aW5nRm9ybSA9IGZhbHNlO1xuICAgICAgICBmb3JtU3RhdGUuZm9ybVN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgZm9ybVN0YXRlLmZvcm1FcnJvciA9IGZhbHNlO1xuICAgICAgICBmb3JtU3RhdGUuaGlkZUZpZWxkcyA9IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBhc3luYyBmdW5jdGlvbiBoYW5kbGVTdWJtaXQoZSl7XG4gICAgICAgIGZvcm1TdGF0ZS5zdWJtaXR0aW5nRm9ybSA9IHRydWU7XG4gICAgICAgIGZvcm1TdGF0ZS5oaWRlRmllbGRzID0gdHJ1ZVxuICAgICAgICBmb3JtU3RhdGUuZm9ybVN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZm9ybUZpZWxkTmFtZXMgPSBbJ25hbWUnLCAnZW1haWwnLCAnbWVzc2FnZSddOyAvLyBUT0RPIC0gZ2VuZXJhdGUgZmllbGQgbmFtZXMgYmFzZWQgb24gaW5wdXRzXG4gICAgICAgIGNvbnN0IGZvcm1UZXh0T2JqID0gYnVpbGRGb3JtU3VibWlzc2lvblRleHRPYmooZS50YXJnZXQsIGZvcm1GaWVsZE5hbWVzKTtcblxuICAgICAgICAvL2NvbnN0IEFQSV9VUkwgPSBgaHR0cHM6Ly9zY3JpcHQuZ29vZ2xlLmNvbS9tYWNyb3Mvcy9BS2Z5Y2J5ZklSWEVlcW5MUFZxNHMyaEdfYjM1bG1jbTJGQ243NjhRV0M5V2ZnL2V4ZWNgO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHsgXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IGZvcm1UZXh0T2JqLFxuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIHVzaW5nIHRoaXMgYmxvY2sgZm9yIHRlc3RpbmcgYW5pbWF0aW9uc1xuICAgICAgICAgICAgZm9ybVN0YXRlLmZvcm1FcnJvciA9IHRydWU7XG4gICAgICAgICAgICBmb3JtU3RhdGUuc3VibWl0dGluZ0Zvcm0gPSBmYWxzZTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzZXRGb3JtKCk7XG4gICAgICAgICAgICAgICAgLy8gZm9ybVN0YXRlLmZvcm1FcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIGZvcm1TdGF0ZS5oaWRlRmllbGRzID0gZmFsc2U7ICAgICAgICAgXG4gICAgICAgICAgICB9LCAxNTAwKVxuICAgICAgICB9LCAxMDAwKVxuICAgICAgICAvLyB0cnkge1xuICAgICAgICAvLyAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKEFQSV9VUkwsIHNldHRpbmdzKTtcbiAgICAgICAgLy8gICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIC8vICAgICBmb3JtU3RhdGUuc3VibWl0dGluZ0Zvcm0gPSBmYWxzZTtcbiAgICAgICAgLy8gICAgIGZvcm1TdGF0ZS5mb3JtU3VjY2VzcyA9IHRydWU7XG4gICAgICAgIC8vIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gICAgIGZvcm1TdGF0ZS5zdWJtaXR0aW5nRm9ybSA9IGZhbHNlO1xuICAgICAgICAvLyAgICAgZm9ybVN0YXRlLmZvcm1TdWNjZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBmb3JtU3RhdGUuZm9ybUVycm9yID0gdHJ1ZTtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdlcnJvciBpbiBzdWJpc3Npb24nLCBlKVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PiB7IC8vIFRPRE8gLSBzZXQgdGhpcyB0byB0cmlnZ2VyIG9ubHkgYWZ0ZXIgbW9kYWwgZGlzc2FwZWFyc1xuICAgICAgICAvLyAgICAgZm9ybVN0YXRlLmZvcm1TdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIC8vIH0sIDE1MDApXG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIHRoaXMgaXMgdGhlIG9uZSBhZGp1c3RlZCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZm9ybVN0YXRlLmZvcm1TdWNjZXNzID0gZmFsc2U7XG4gICAgICAgIH0sIDI1MDApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRGb3JtU3VibWlzc2lvblRleHRPYmooZm9ybUV2ZW50VGFyZ2V0LCBmb3JtRmllbGROYW1lcyl7XG4gICAgICAgbGV0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgXG4gICAgICAgIGZvcm1GaWVsZE5hbWVzLmZvckVhY2goZmllbGROYW1lID0+IHtcbiAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2ZpZWxkTmFtZX1gLCBgJHtmb3JtRXZlbnRUYXJnZXRbZmllbGROYW1lXS52YWx1ZX1gKTtcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gZm9ybURhdGFcbiAgICB9XG5cbiAgICAvLyBmdW5jdGlvbiB2YWxpZGF0ZUVtYWlsKGV2ZW50KSB7XG4gICAgLy8gICAgIGZvcm1TdGF0ZS5mb3JtRXJyb3IgPSBmYWxzZTtcbiAgICAvLyAgICBsZXQgdGV4dGJveCA9IGV2ZW50LnRhcmdldDtcbiAgICAvLyAgICBpZiAodGV4dGJveC52YWx1ZSA9PT0gJycpIHtcbiAgICAvLyAgICAgICAgIHRleHRib3guc2V0Q3VzdG9tVmFsaWRpdHkoJ1JlcXVpcmVkIGVtYWlsIGFkZHJlc3MnKTtcbiAgICAvLyAgICAgfSBlbHNlIGlmICh0ZXh0Ym94LnZhbGlkaXR5LnR5cGVNaXNtYXRjaCl7XG4gICAgLy8gICAgICAgICBmb3JtU3RhdGUuZm9ybUVycm9yID0gdHJ1ZTtcbiAgICAvLyAgICAgICAgIHRleHRib3guc2V0Q3VzdG9tVmFsaWRpdHkoJ3BsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MnKTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgdGV4dGJveC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gfVxuXG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG4gICAudGV4dC1jb250YWluZXIgaDJ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzByZW07XG4gICAgICAgIGNvbG9yOiAjODA4MDgwO1xuICAgICAgICBcbiAgICB9XG4gICAgLnRleHQtY29udGFpbmVyIGgyOjphZnRlcntcbiAgICAgICAgY29udGVudDogJyc7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBoZWlnaHQ6IDdweDtcbiAgICAgICAgbWFyZ2luOiA1cmVtIDBweCAxOHJlbSAwcHg7XG4gICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0Z3JheTtcbiAgICB9XG5cbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKXtcbiAgICAgICAgaDI6OmFmdGVyIHtcbiAgICAgICAgICAgIHdpZHRoOiAyNTBweDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB7XG4gICAgICAgIG1hcmdpbjogNnJlbSAwcmVtIDEwcmVtIDByZW07XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJywgc2Fucy1zZXJpZjtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICAgICAgZm9udC1zaXplOiAxM3JlbTtcbiAgICAgICAgY29sb3I6ICM1ODU5NWJcbiAgICB9XG5cbiAgICBkaXYuZm9ybS1jb250YWluZXJ7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIGNvbG9yOiBncmF5O1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICBwYWRkaW5nOiAxNXJlbSAyMHJlbSA0MHJlbSAyMHJlbTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgZ3JheTtcbiAgICAgICAgYm94LXNoYWRvdzogNXB4IDVweCA1cHggbGlnaHRncmF5O1xuICAgIH1cblxuICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pe1xuICAgICAgICBkaXYuZm9ybS1jb250YWluZXIge1xuICAgICAgICAgICAgcGFkZGluZzogMzByZW0gMjByZW0gNDByZW0gMjByZW07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXYuZmxleC1jb250YWluZXJ7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgfSBcblxuICAgIEBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pe1xuICAgICAgICBkaXYuZmxleC1jb250YWluZXIge1xuICAgICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpdi50ZXh0LWNvbnRhaW5lciB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG5cbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKXtcbiAgICAgICAgZGl2LnRleHQtY29udGFpbmVyIHtcbiAgICAgICAgICAgIHRvcDogLTIwcHg7XG4gICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAzMHJlbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpdntcbiAgICAgICAgZmxleDogNTUlO1xuICAgIH1cblxuICAgIGZvcm17XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGZsZXg6IDUwJTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiBhdXRvO1xuICAgIH1cbiAgICBsYWJlbHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgbWFyZ2luOiA0cmVtIDBweDtcbiAgICB9XG4gICAgc3BhbntcbiAgICAgICAgZm9udC1zaXplOiAxMXJlbTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNXJlbTtcbiAgICB9XG4gICAgaW5wdXQsIHRleHRhcmVhe1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBncmF5O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTByZW07XG4gICAgICAgIHBhZGRpbmc6IDdyZW07XG4gICAgICAgIGJveC1zaGFkb3c6IC4zcHggLjNweCAuM3B4IGdyYXk7XG4gICAgfVxuXG4gICAgaW5wdXRbdHlwZT1cInN1Ym1pdFwiXXtcbiAgICAgICAgd2lkdGg6IDUwJTtcbiAgICAgICAgbWFyZ2luLXRvcDogMTJyZW07XG4gICAgICAgIHBhZGRpbmc6IDZyZW07XG4gICAgICAgIGJveC1zaGFkb3c6IC41cHggMXB4IDFweCBncmF5O1xuICAgICAgICBjb2xvcjogI2QzZDNkMztcbiAgICAgICAgYmFja2dyb3VuZDogIzU4NTk1YjtcbiAgICAgICAgbWluLXdpZHRoOiBmaXQtY29udGVudDtcbiAgICB9XG5cbiAgICBAbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKXtcbiAgICAgICAgaW5wdXRbdHlwZT1cInN1Ym1pdFwiXXtcbiAgICAgICAgICAgIHdpZHRoOiAzNSU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXYuY29udGFjdC1yb3d7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICB9XG4gICAgaW5wdXQsIHRleHRhcmVhe1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCBsaWdodGdyYXk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgZm9udC1zaXplOiAxMHJlbTtcbiAgICAgICAgcGFkZGluZzogM3JlbTtcbiAgICAgICAgYm94LXNoYWRvdzogLjNweCAuM3B4IC4zcHggZ3JheTtcbiAgICAgICBcbiAgICB9XG5cbiAgICAuc3VjY2Vzcy1tZXNzYWdlIHtcbiAgICAgICAgZm9udC1zaXplOiA1MHJlbTtcbiAgICAgICAgLyogY29sb3I6IGRhcmtvbGl2ZWdyZWVuOyAqL1xuICAgICAgICBjb2xvcjogIzU4NTk1YjtcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICB9XG5cbiAgICAuZ2Zvcm0sIC50ZXh0LWNvbnRhaW5lciwgLnN1Y2Nlc3MtbWVzc2FnZSB7XG4gICAgICAgIHRyYW5zaXRpb246IC4zNXMgb3BhY2l0eSBlYXNlO1xuICAgIH1cbiAgICAuaGlkZS1jb250ZW50e1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgIH1cbjwvc3R5bGU+XG5cbnsjaWYgc2hvd01vZGFsICYmIGhpZGVNb2RhbCA9PT0gZmFsc2V9XG5cdDxNb2RhbFRlbXBsYXRlIHNob3dNb2RhbD17c2hvd01vZGFsfSBvbjpjbGljaz5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmxleC1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRleHQtY29udGFpbmVyIHtmb3JtU3RhdGUuaGlkZUZpZWxkcyA/ICdoaWRlLWNvbnRlbnQnIDogJyd9IHtmb3JtU3RhdGUuaGlkZUZpZWxkcyA/ICdoaWRlLWNvbnRlbnQnIDogJyd9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDI+R2V0IEluIFRvdWNoPC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0IGNvbnNlY3RldHVyLCBhZGlwaXNpY2luZyBlbGl0LiBcbiAgICAgICAgICAgICAgICAgICAgICAgIE5lY2Vzc2l0YXRpYnVzIHN1c2NpcGl0IHF1aWJ1c2RhbSBlbGlnZW5kaSBhbGlhcyBhLCBjdW0gc2l0IGF1dGVtIHF1YXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBRdWlidXNkYW0gbWluaW1hIGFyY2hpdGVjdG8gcXVhbSB2b2x1cHRhdGVtLiBOZWNlc3NpdGF0aWJ1cywgcXVpc3F1YW0/PC9wPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImdmb3JtIHtmb3JtU3RhdGUuaGlkZUZpZWxkcyA/ICdoaWRlLWNvbnRlbnQnIDogJyd9XG4gICAgICAgICAgICAgICAgICAgICAgICB7Zm9ybVN0YXRlLmZvcm1TdWNjZXNzID8gJ2hpZGUtY29udGVudCcgOiAnJ31cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtoYW5kbGVTdWJtaXR9ICBcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD4gPHNwYW4+TmFtZTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9XCJuYW1lXCIgdHlwZT1cInRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPiA8c3Bhbj5FbWFpbDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgbmFtZT1cImVtYWlsXCIgdHlwZT1cImVtYWlsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPiA8c3Bhbj5NZXNzYWdlPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBuYW1lPVwibWVzc2FnZVwiIHJvd3M9XCI2XCIgdHlwZT1cInRleHRhcmVhXCI+IDwvdGV4dGFyZWE+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIlNlbmQgTWVzc2FnZVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgIDwhLS0gPEJveExvYWRlciAvPiAtLT5cbiAgICAgICAgICAgICAgICB7I2lmIGZvcm1TdGF0ZS5zdWJtaXR0aW5nRm9ybX1cbiAgICAgICAgICAgICAgICAgICAgPEJveExvYWRlciAvPlxuICAgICAgICAgICAgICAgIHsvaWZ9XG4gICAgICAgICAgICAgICAgeyNpZiBmb3JtU3RhdGUuZm9ybVN1Y2Nlc3N9XG4gICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cInN1Y2Nlc3MtbWVzc2FnZVwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgaW46Zmx5PVwie3sgeTogMjAsIGR1cmF0aW9uOiA1MDAsIGRlbGF5OiAyMDAsIH19XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDpmbHk9XCJ7eyB5OiAtMjAsIGR1cmF0aW9uOiA1MDAsIGRlbGF5OiAwLCB9fVwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIFNVQ0NFU1NcbiAgICAgICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgICAgIHsjaWYgZm9ybVN0YXRlLmZvcm1FcnJvcn1cbiAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzPVwic3VjY2Vzcy1tZXNzYWdlXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICBpbjpmbHk9XCJ7eyB5OiAyMCwgZHVyYXRpb246IDUwMCwgZGVsYXk6IDIwMCwgfX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0OmZseT1cInt7IHk6IC0yMCwgZHVyYXRpb246IDUwMCwgZGVsYXk6IDAsIH19XCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgRVJST1JcbiAgICAgICAgICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgICAgICB7L2lmfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXHQ8L01vZGFsVGVtcGxhdGU+XG57L2lmfSIsIjxzY3JpcHQ+XG5pbXBvcnQgSGFtYnVyZ2VyIGZyb20gJy4vSGFtYnVyZ2VyLnN2ZWx0ZSc7XG5pbXBvcnQgQ29udGFjdE1vZGFsIGZyb20gJy4uL21vZGFscy9Db250YWN0TW9kYWwuc3ZlbHRlJztcblxuaW1wb3J0IHsgb25Nb3VudCB9IGZyb20gJ3N2ZWx0ZSc7XG5cbmxldCBzaG93TW9kYWw7XG5sZXQgbGlua3MgPSBbXVxuXG5vbk1vdW50KCgpPT57XG4gICAgbGlua3MuZm9yRWFjaCgobGluayk9PntcbiAgICAgICAgY29uc29sZS5sb2cobGluaylcbiAgICB9KVxufSlcblxubGV0IHdpbmRvd1k7XG5sZXQgaGFtYnVyZ2VyO1xubGV0IHRvZ2dsZSA9IGZhbHNlO1xuXG5sZXQgcmVkdWNlTmF2U2l6ZSA9IGZhbHNlO1xuXG4kOiBoZWFkZXJDbGFzcyA9IG5hdlNpemUod2luZG93WSk7XG5cbmZ1bmN0aW9uIG5hdlNpemUoeSl7XG4gICAgaWYoeSA+IDc1KXtcbiAgICAgICAgcmVkdWNlTmF2U2l6ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVkdWNlTmF2U2l6ZSA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9nZ2xlck9mZigpe1xuICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDwgODIwKXtcbiAgICAgICAgaGFtYnVyZ2VyID8gaGFtYnVyZ2VyLiQkLmN0eC5oYW1idXJnZXIuY2xpY2soKSA6IG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvcGVuTW9kYWwoKXtcbiAgICBzaG93TW9kYWwgPSB0cnVlO1xufVxuXG48L3NjcmlwdD5cblxuPHN0eWxlPlxuXG5oZWFkZXIge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZDZkNmQ2O1xuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB0b3A6IDA7XG4gICAgei1pbmRleDogNTA7XG4gICAgYmFja2dyb3VuZDogd2hpdGU7XG59XG5cbm5hdiB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nOiAzMHJlbSAyMHJlbTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjQ1cyBjdWJpYy1iZXppZXIoMC44NSwgMC4wOCwgMC4wOCwgMC45OSk7XG59XG5cbm5hdi5zY3JvbGxlZCB7XG4gICAgcGFkZGluZzogMjByZW0gMjByZW07XG59XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pIHtcbiAgICBuYXYge1xuICAgICAgICBwYWRkaW5nOiAzNXJlbSA0MHJlbTtcbiAgICB9XG4gICAgbmF2LnNjcm9sbGVkIHtcbiAgICAgICAgcGFkZGluZzogMjByZW0gNDByZW07XG4gICAgfVxufVxuXG51bC5uYXZpZ2F0aW9uIHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHotaW5kZXg6IDI7XG4gICAgd2lkdGg6IDI1MHB4O1xuICAgIHJpZ2h0OiAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMDAlKTtcbiAgICBib3R0b206IDA7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIHBhZGRpbmc6IDByZW0gMjByZW07XG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDFzIGN1YmljLWJlemllcigwLjg1LCAwLjA4LCAwLjA4LCAwLjk5KTtcbn1cblxuI3RvZ2dsZTpjaGVja2VkIH4gdWwubmF2aWdhdGlvbntcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTtcbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSkge1xuICAgIHVsLm5hdmlnYXRpb24ge1xuICAgICAgICBwYWRkaW5nOiAwcmVtIDQwcmVtO1xuICAgIH1cbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSkge1xuICAgIHVsLm5hdmlnYXRpb257XG4gICAgICAgIHRyYW5zZm9ybTogdW5zZXQ7ICAgXG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgd2lkdGg6IHVuc2V0O1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cbn1cblxubGkge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcbiAgICBwYWRkaW5nOiA1cmVtIDByZW07XG4gICAgd2lkdGg6IGF1dG87XG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgIGZvbnQtc2l6ZTogMTRyZW07XG59XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pe1xuICAgIGxpIHtcbiAgICAgICAgZm9udC1zaXplOiAxNnJlbTtcbiAgICAgICAgbWFyZ2luOiAwcmVtIDE1cmVtO1xuICAgIH1cbiAgICBwe1xuICAgICAgICBmb250LXNpemU6IDE4cmVtO1xuICAgIH1cbn1cblxubGk6bm90KC5jbG9zZS1jb250YWluZXIpOjphZnRlciwgLmFjdGl2ZTo6YWZ0ZXIge1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBsZWZ0OiAwO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMDAlKTtcbiAgICBib3R0b206IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgb3BhY2l0eTogMTtcbiAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgIzNCM0IzQjtcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gLjQ1cyBjdWJpYy1iZXppZXIoMC44NSwgMC4wOCwgMC4wOCwgMC45OSk7XG59XG5cbmxpOm5vdCguY2xvc2UtY29udGFpbmVyKTpob3Zlcjo6YWZ0ZXIsIC5hY3RpdmU6OmFmdGVyIHtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XG59XG5cbi5jbG9zZS1jb250YWluZXIge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDUwcmVtO1xuICAgIHJpZ2h0OiA1MHJlbTtcbiAgICBvdmVyZmxvdzogdW5zZXQ7XG59XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDQwZW0pe1xuICAgIC5jbG9zZS1jb250YWluZXIge1xuICAgICAgICByaWdodDogNzByZW07XG4gICAgfVxufVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA2NGVtKXtcbiAgICAuY2xvc2UtY29udGFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICB9XG59XG5cbi5jbG9zZSB7XG4gICAgd2lkdGg6MzJweDtcbiAgICBoZWlnaHQ6MzJweDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cblxuLmNsb3NlOjpiZWZvcmUge1xuICBjb250ZW50OiAnJztcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIGJsYWNrO1xuICB3aWR0aDogMzJweDtcbiAgdHJhbnNmb3JtOiByb3RhdGUoNDVkZWcpO1xufVxuXG4uY2xvc2U6OmFmdGVyIHtcbiAgY29udGVudDogJyc7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjaztcbiAgd2lkdGg6IDMycHg7XG4gIHRyYW5zZm9ybTogcm90YXRlKC00NWRlZyk7XG59XG5cbmE6bm90KC5sb2dvKSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcGFkZGluZzogNXJlbSAwcmVtO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG59XG5cbnB7XG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG59XG4uY29kZSB7XG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgb3BhY2l0eTogLjM7XG59XG5cbi5sb2dvLWhvdmVyIHtcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2UtaW47XG59XG5cbi5sb2dvOmhvdmVyIC5sb2dvLWhvdmVyIHtcbiAgICBjb2xvcjogYmxhY2s7XG4gICAgXG59XG5cbjwvc3R5bGU+XG5cbjxzdmVsdGU6d2luZG93IGJpbmQ6c2Nyb2xsWT17d2luZG93WX0vPlxuPCEtLSBjbGFzcz17cmVkdWNlTmF2U2l6ZSA/ICdzY3JvbGxlZCcgOiAnJ30gLS0+XG48aGVhZGVyID5cbiAgICA8bmF2IGNsYXNzPXtyZWR1Y2VOYXZTaXplID8gJ3Njcm9sbGVkIGNvbnRhaW5lcicgOiAnY29udGFpbmVyJ30+XG4gICAgICAgIDxhIGhyZWY9Jy8nIGNsYXNzPVwibG9nb1wiPlxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb2RlXCI+Jmx0O2gxJmd0Ozwvc3Bhbj5IaSBUaGVyZTxzcGFuIGNsYXNzPVwibG9nby1ob3ZlclwiPiE8L3NwYW4+PHNwYW4gY2xhc3M9XCJjb2RlXCI+Jmx0Oy9oMSZndDs8L3NwYW4+XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPEhhbWJ1cmdlciB0b2dnbGU9e3RvZ2dsZX0gYmluZDp0aGlzPXtoYW1idXJnZXJ9IC8+XG4gICAgICAgIDx1bCBjbGFzcz1cIm5hdmlnYXRpb25cIj5cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImNsb3NlLWNvbnRhaW5lclwiIG9uOmNsaWNrPXt0b2dnbGVyT2ZmfSA+PHNwYW4gY2xhc3M9XCJjbG9zZVwiPjwvc3Bhbj48L2xpPlxuICAgICAgICAgICAgPGxpPjxhIGNsYXNzPVwiXCIgb246Y2xpY2s9e3RvZ2dsZXJPZmZ9IGJpbmQ6dGhpcz17bGlua3NbMF19IGhyZWY9XCIvXCI+SG9tZTwvYT48L2xpPlxuICAgICAgICAgICAgPGxpPjxhIG9uOmNsaWNrPXt0b2dnbGVyT2ZmfSBiaW5kOnRoaXM9e2xpbmtzWzFdfSBocmVmPVwiL2Fib3V0XCI+QWJvdXQ8L2E+PC9saT5cbiAgICAgICAgICAgIDxsaT48YSBvbjpjbGljaz17b3Blbk1vZGFsfSBocmVmPVwiamF2YXNjcmlwdDp2b2lkKDApXCI+Q29udGFjdDwvYT48L2xpPlxuICAgICAgICA8L3VsPlxuICAgIDwvbmF2PlxuPC9oZWFkZXI+XG5cbjxDb250YWN0TW9kYWwgb246Y2xpY2s9J3soKSA9PiBzaG93TW9kYWwgPSBmYWxzZX0nIHNob3dNb2RhbD17c2hvd01vZGFsfS8+IiwiPHNjcmlwdD5cbmltcG9ydCBUZXh0QW5pbWF0aW9uIGZyb20gJy4uL2hlbHBlckNvbXBvbmVudHMvVGV4dEFuaW1hdGlvbi5zdmVsdGUnO1xuXG48L3NjcmlwdD5cblxuPHN0eWxlPlxuZm9vdGVyIHtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgI2Q2ZDZkNjtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICBjb2xvcjogIzNCM0IzQjtcbn1cblxuLmZvb3Rlci1jb250YWluZXIge1xuICAgIG1hcmdpbi10b3A6IDQwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xufVxuXG5AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOiA0MGVtKXtcbiAgICAuZm9vdGVyLWNvbnRhaW5lciB7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgfVxufVxuXG4ubGVmdCwgLnJpZ2h0IHtcbiAgICBtYXJnaW4tYm90dG9tOiA0MHJlbTtcbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNDBlbSl7XG4gICAgLmxlZnR7XG4gICAgICAgIHBhZGRpbmctcmlnaHQ6IDgwcmVtO1xuICAgICAgICB3aWR0aDo2MCU7XG4gICAgfVxuICAgIC5yaWdodCB7XG4gICAgICAgIHBhZGRpbmctdG9wOiAyMHJlbTtcbiAgICB9XG59XG5cbkBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IDY0ZW0pe1xuICAgIC5sZWZ0IHtcbiAgICAgICAgd2lkdGg6IDUwJTtcbiAgICB9XG59XG5cbi50ZXh0LWN0YTpmaXJzdC1vZi10eXBlIHtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHJlbTtcbn1cblxuLmhlYWRsaW5lIHtcbiAgICBmb250LXNpemU6IDQwcHg7XG4gICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgJ1JvYm90bycsICdPeHlnZW4nLCAnVWJ1bnR1JywgJ0ZpcmEgU2FucycsICdEcm9pZCBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcbiAgICBsaW5lLWhlaWdodDogNDVweDtcbiAgICBmb250LXdlaWdodDogNzAwO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG59XG5cbi5oZWFkbGluZSBhIHtcbiAgICBjb2xvcjogIzU4NTk1YjtcbiAgICB0cmFuc2l0aW9uOiBhbGwgLjQ1cyBlYXNlLWluLW91dDtcbiAgICBvcGFjaXR5OiAuNzU7XG59XG5cbi5oZWFkbGluZSBhOmhvdmVyIHtcbiAgICBjb2xvcjogYmxhY2s7XG59XG5cbi50aXRsZSB7XG4gICAgZm9udC13ZWlnaHQ6IDEwMDtcbiAgICBmb250LXNpemU6IDEycmVtO1xufVxuXG4udGV4dC1jdGEgYSB7XG4gICAgZm9udC1zaXplOiAxNHJlbTtcbn1cblxuLmNvcHlyaWdodCB7XG4gICAgZm9udC1zaXplOiAxMnJlbTtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgZm9udC13ZWlnaHQ6IDMwMDtcbn1cblxuQG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDogNjRlbSl7XG4gICAgLnRpdGxle1xuICAgICAgICBmb250LXNpemU6IDE2cmVtXG4gICAgfVxuICAgIC50ZXh0LWN0YSBhIHtcbiAgICAgICAgZm9udC1zaXplOiAxOHJlbTtcbiAgICB9XG4gICAgLmNvcHlyaWdodCB7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRyZW07XG4gICAgfVxuICAgIC5oZWFkbGluZSB7XG4gICAgICAgIGZvbnQtc2l6ZTogNDVweDtcbiAgICB9XG59XG5cbjwvc3R5bGU+XG5cbjxmb290ZXI+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBmb290ZXItY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gICAgICAgICAgICA8cCBjbGFzcz1cImhlYWRsaW5lXCI+XG4gICAgICAgICAgICAgICAgRmVlbCBmcmVlIHRvIHNob290IG1lIGFuIDxhIGhyZWY9XCJtYWlsdG86am9zaHVhLm1pY2FoLnRvcGVyQGdtYWlsLmNvbVwiPmVtYWlsPC9hPiAmIGNvbm5lY3Qgb24gPGEgaHJlZj1cImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9qci1kZXZcIiB0YXJnZXQ9XCJibGFua1wiPnNvY2lhbDwvYT5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGV4dC1jdGFcIj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cInRpdGxlXCI+XG4gICAgICAgICAgICAgICAgICAgIEdldCBJbiBUb3VjaCFcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIm1haWx0bzpqb3NodWEubWljYWgudG9wZXJAZ21haWwuY29tXCI+XG4gICAgICAgICAgICAgICAgICAgIDxUZXh0QW5pbWF0aW9uIHRleHQ9e2BKb3NodWEubWljYWgucm9wZXJAZ21haWwuY29tYH0gLz5cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LWN0YVwiPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwidGl0bGVcIj5cbiAgICAgICAgICAgICAgICAgICAgVmlldyBSZXN1bWVcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIi4vaW1hZ2VzL3Jlc3VtZS12MkRlc2lnbjIucGRmXCIgZG93bmxvYWQ+XG4gICAgICAgICAgICAgICAgICAgIDxUZXh0QW5pbWF0aW9uIHRleHQ9e2BEb3dubG9hZCBQREZgfSAvPlxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8cCBjbGFzcz1cImNvcHlyaWdodCBjb250YWluZXJcIj5cbiAgICAgICAgQCAyMDE5IEpvc2h1YSBSb3BlciBEZXZlbG9wbWVudFxuICAgIDwvcD5cbjwvZm9vdGVyPiIsIjxzY3JpcHQ+XG5cdGV4cG9ydCBsZXQgc3RhdHVzO1xuXHRleHBvcnQgbGV0IGVycm9yO1xuXG5cdGNvbnN0IGRldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0aDEsIHAge1xuXHRcdG1hcmdpbjogMCBhdXRvO1xuXHR9XG5cblx0aDEge1xuXHRcdGZvbnQtc2l6ZTogMi44ZW07XG5cdFx0Zm9udC13ZWlnaHQ6IDcwMDtcblx0XHRtYXJnaW46IDAgMCAwLjVlbSAwO1xuXHR9XG5cblx0cCB7XG5cdFx0bWFyZ2luOiAxZW0gYXV0bztcblx0fVxuXG5cdEBtZWRpYSAobWluLXdpZHRoOiA0ODBweCkge1xuXHRcdGgxIHtcblx0XHRcdGZvbnQtc2l6ZTogNGVtO1xuXHRcdH1cblx0fVxuPC9zdHlsZT5cblxuPHN2ZWx0ZTpoZWFkPlxuXHQ8dGl0bGU+e3N0YXR1c308L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPGgxPntzdGF0dXN9PC9oMT5cblxuPHA+e2Vycm9yLm1lc3NhZ2V9PC9wPlxuXG57I2lmIGRldiAmJiBlcnJvci5zdGFja31cblx0PHByZT57ZXJyb3Iuc3RhY2t9PC9wcmU+XG57L2lmfVxuIiwiPCEtLSBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IFNhcHBlciDigJQgZG8gbm90IGVkaXQgaXQhIC0tPlxuPHNjcmlwdD5cblx0aW1wb3J0IHsgc2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XG5cdGltcG9ydCB7IENPTlRFWFRfS0VZIH0gZnJvbSAnLi9zaGFyZWQnO1xuXHRpbXBvcnQgTGF5b3V0IGZyb20gJy4uLy4uLy4uL3JvdXRlcy9fbGF5b3V0LnN2ZWx0ZSc7XG5cdGltcG9ydCBFcnJvciBmcm9tICcuLi8uLi8uLi9yb3V0ZXMvX2Vycm9yLnN2ZWx0ZSc7XG5cblx0ZXhwb3J0IGxldCBzdG9yZXM7XG5cdGV4cG9ydCBsZXQgZXJyb3I7XG5cdGV4cG9ydCBsZXQgc3RhdHVzO1xuXHRleHBvcnQgbGV0IHNlZ21lbnRzO1xuXHRleHBvcnQgbGV0IGxldmVsMDtcblx0ZXhwb3J0IGxldCBsZXZlbDEgPSBudWxsO1xuXG5cdHNldENvbnRleHQoQ09OVEVYVF9LRVksIHN0b3Jlcyk7XG48L3NjcmlwdD5cblxuPExheW91dCBzZWdtZW50PVwie3NlZ21lbnRzWzBdfVwiIHsuLi5sZXZlbDAucHJvcHN9PlxuXHR7I2lmIGVycm9yfVxuXHRcdDxFcnJvciB7ZXJyb3J9IHtzdGF0dXN9Lz5cblx0ezplbHNlfVxuXHRcdDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9XCJ7bGV2ZWwxLmNvbXBvbmVudH1cIiB7Li4ubGV2ZWwxLnByb3BzfS8+XG5cdHsvaWZ9XG48L0xheW91dD4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IFNhcHBlciDigJQgZG8gbm90IGVkaXQgaXQhXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJvb3QgfSBmcm9tICcuLi8uLi8uLi9yb3V0ZXMvX2xheW91dC5zdmVsdGUnO1xuZXhwb3J0IHsgcHJlbG9hZCBhcyByb290X3ByZWxvYWQgfSBmcm9tICcuL3NoYXJlZCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVycm9yQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vcm91dGVzL19lcnJvci5zdmVsdGUnO1xuXG5leHBvcnQgY29uc3QgaWdub3JlID0gWy9eXFwvYmxvZy5qc29uJC8sIC9eXFwvYmxvZ1xcLyhbXlxcL10rPykuanNvbiQvXTtcblxuZXhwb3J0IGNvbnN0IGNvbXBvbmVudHMgPSBbXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL2luZGV4LnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOmluZGV4LnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvYWJvdXQuc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6YWJvdXQuc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9ibG9nL2luZGV4LnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOmJsb2cvaW5kZXguc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9ibG9nL1tzbHVnXS5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpibG9nL1tzbHVnXS5zdmVsdGVfX1wiXG5cdH1cbl07XG5cbmV4cG9ydCBjb25zdCByb3V0ZXMgPSAoZCA9PiBbXG5cdHtcblx0XHQvLyBpbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcLyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IGk6IDAgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gYWJvdXQuc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9hYm91dFxcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiAxIH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIGJsb2cvaW5kZXguc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9ibG9nXFwvPyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IGk6IDIgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gYmxvZy9bc2x1Z10uc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9ibG9nXFwvKFteXFwvXSs/KVxcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0bnVsbCxcblx0XHRcdHsgaTogMywgcGFyYW1zOiBtYXRjaCA9PiAoeyBzbHVnOiBkKG1hdGNoWzFdKSB9KSB9XG5cdFx0XVxuXHR9XG5dKShkZWNvZGVVUklDb21wb25lbnQpO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0aW1wb3J0KFwiL1VzZXJzL2pvc2hyb3Blci9EZXNrdG9wL3JlcG9zL3BvcnRmb2xpby1zdmVsdGUvcG9ydGZvbGlvLXN2ZWx0ZS1zYXAvbm9kZV9tb2R1bGVzL3NhcHBlci9zYXBwZXItZGV2LWNsaWVudC5qc1wiKS50aGVuKGNsaWVudCA9PiB7XG5cdFx0Y2xpZW50LmNvbm5lY3QoMTAwMDApO1xuXHR9KTtcbn0iLCJpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcbmltcG9ydCB7IENPTlRFWFRfS0VZIH0gZnJvbSAnLi9pbnRlcm5hbC9zaGFyZWQnO1xuaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xuaW1wb3J0IEFwcCBmcm9tICcuL2ludGVybmFsL0FwcC5zdmVsdGUnO1xuaW1wb3J0IHsgaWdub3JlLCByb3V0ZXMsIHJvb3RfcHJlbG9hZCwgY29tcG9uZW50cywgRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2ludGVybmFsL21hbmlmZXN0LWNsaWVudCc7XG5cbmZ1bmN0aW9uIGdvdG8oaHJlZiwgb3B0cyA9IHsgcmVwbGFjZVN0YXRlOiBmYWxzZSB9KSB7XG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQobmV3IFVSTChocmVmLCBkb2N1bWVudC5iYXNlVVJJKSk7XG5cblx0aWYgKHRhcmdldCkge1xuXHRcdF9oaXN0b3J5W29wdHMucmVwbGFjZVN0YXRlID8gJ3JlcGxhY2VTdGF0ZScgOiAncHVzaFN0YXRlJ10oeyBpZDogY2lkIH0sICcnLCBocmVmKTtcblx0XHRyZXR1cm4gbmF2aWdhdGUodGFyZ2V0LCBudWxsKS50aGVuKCgpID0+IHt9KTtcblx0fVxuXG5cdGxvY2F0aW9uLmhyZWYgPSBocmVmO1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZiA9PiB7fSk7IC8vIG5ldmVyIHJlc29sdmVzXG59XG5cbmNvbnN0IGluaXRpYWxfZGF0YSA9IHR5cGVvZiBfX1NBUFBFUl9fICE9PSAndW5kZWZpbmVkJyAmJiBfX1NBUFBFUl9fO1xuXG5sZXQgcmVhZHkgPSBmYWxzZTtcbmxldCByb290X2NvbXBvbmVudDtcbmxldCBjdXJyZW50X3Rva2VuO1xubGV0IHJvb3RfcHJlbG9hZGVkO1xubGV0IGN1cnJlbnRfYnJhbmNoID0gW107XG5sZXQgY3VycmVudF9xdWVyeSA9ICd7fSc7XG5cbmNvbnN0IHN0b3JlcyA9IHtcblx0cGFnZTogd3JpdGFibGUoe30pLFxuXHRwcmVsb2FkaW5nOiB3cml0YWJsZShudWxsKSxcblx0c2Vzc2lvbjogd3JpdGFibGUoaW5pdGlhbF9kYXRhICYmIGluaXRpYWxfZGF0YS5zZXNzaW9uKVxufTtcblxubGV0ICRzZXNzaW9uO1xubGV0IHNlc3Npb25fZGlydHk7XG5cbnN0b3Jlcy5zZXNzaW9uLnN1YnNjcmliZShhc3luYyB2YWx1ZSA9PiB7XG5cdCRzZXNzaW9uID0gdmFsdWU7XG5cblx0aWYgKCFyZWFkeSkgcmV0dXJuO1xuXHRzZXNzaW9uX2RpcnR5ID0gdHJ1ZTtcblxuXHRjb25zdCB0YXJnZXQgPSBzZWxlY3RfdGFyZ2V0KG5ldyBVUkwobG9jYXRpb24uaHJlZikpO1xuXG5cdGNvbnN0IHRva2VuID0gY3VycmVudF90b2tlbiA9IHt9O1xuXHRjb25zdCB7IHJlZGlyZWN0LCBwcm9wcywgYnJhbmNoIH0gPSBhd2FpdCBoeWRyYXRlX3RhcmdldCh0YXJnZXQpO1xuXHRpZiAodG9rZW4gIT09IGN1cnJlbnRfdG9rZW4pIHJldHVybjsgLy8gYSBzZWNvbmRhcnkgbmF2aWdhdGlvbiBoYXBwZW5lZCB3aGlsZSB3ZSB3ZXJlIGxvYWRpbmdcblxuXHRhd2FpdCByZW5kZXIocmVkaXJlY3QsIGJyYW5jaCwgcHJvcHMsIHRhcmdldC5wYWdlKTtcbn0pO1xuXG5sZXQgcHJlZmV0Y2hpbmdcblxuXG4gPSBudWxsO1xuZnVuY3Rpb24gc2V0X3ByZWZldGNoaW5nKGhyZWYsIHByb21pc2UpIHtcblx0cHJlZmV0Y2hpbmcgPSB7IGhyZWYsIHByb21pc2UgfTtcbn1cblxubGV0IHRhcmdldDtcbmZ1bmN0aW9uIHNldF90YXJnZXQoZWxlbWVudCkge1xuXHR0YXJnZXQgPSBlbGVtZW50O1xufVxuXG5sZXQgdWlkID0gMTtcbmZ1bmN0aW9uIHNldF91aWQobikge1xuXHR1aWQgPSBuO1xufVxuXG5sZXQgY2lkO1xuZnVuY3Rpb24gc2V0X2NpZChuKSB7XG5cdGNpZCA9IG47XG59XG5cbmNvbnN0IF9oaXN0b3J5ID0gdHlwZW9mIGhpc3RvcnkgIT09ICd1bmRlZmluZWQnID8gaGlzdG9yeSA6IHtcblx0cHVzaFN0YXRlOiAoc3RhdGUsIHRpdGxlLCBocmVmKSA9PiB7fSxcblx0cmVwbGFjZVN0YXRlOiAoc3RhdGUsIHRpdGxlLCBocmVmKSA9PiB7fSxcblx0c2Nyb2xsUmVzdG9yYXRpb246ICcnXG59O1xuXG5jb25zdCBzY3JvbGxfaGlzdG9yeSA9IHt9O1xuXG5mdW5jdGlvbiBleHRyYWN0X3F1ZXJ5KHNlYXJjaCkge1xuXHRjb25zdCBxdWVyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGlmIChzZWFyY2gubGVuZ3RoID4gMCkge1xuXHRcdHNlYXJjaC5zbGljZSgxKS5zcGxpdCgnJicpLmZvckVhY2goc2VhcmNoUGFyYW0gPT4ge1xuXHRcdFx0bGV0IFssIGtleSwgdmFsdWUgPSAnJ10gPSAvKFtePV0qKSg/Oj0oLiopKT8vLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHNlYXJjaFBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpKSk7XG5cdFx0XHRpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICdzdHJpbmcnKSBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV1dO1xuXHRcdFx0aWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSAnb2JqZWN0JykgKHF1ZXJ5W2tleV0gKS5wdXNoKHZhbHVlKTtcblx0XHRcdGVsc2UgcXVlcnlba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBxdWVyeTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0X3RhcmdldCh1cmwpIHtcblx0aWYgKHVybC5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikgcmV0dXJuIG51bGw7XG5cdGlmICghdXJsLnBhdGhuYW1lLnN0YXJ0c1dpdGgoaW5pdGlhbF9kYXRhLmJhc2VVcmwpKSByZXR1cm4gbnVsbDtcblxuXHRsZXQgcGF0aCA9IHVybC5wYXRobmFtZS5zbGljZShpbml0aWFsX2RhdGEuYmFzZVVybC5sZW5ndGgpO1xuXG5cdGlmIChwYXRoID09PSAnJykge1xuXHRcdHBhdGggPSAnLyc7XG5cdH1cblxuXHQvLyBhdm9pZCBhY2NpZGVudGFsIGNsYXNoZXMgYmV0d2VlbiBzZXJ2ZXIgcm91dGVzIGFuZCBwYWdlIHJvdXRlc1xuXHRpZiAoaWdub3JlLnNvbWUocGF0dGVybiA9PiBwYXR0ZXJuLnRlc3QocGF0aCkpKSByZXR1cm47XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRjb25zdCByb3V0ZSA9IHJvdXRlc1tpXTtcblxuXHRcdGNvbnN0IG1hdGNoID0gcm91dGUucGF0dGVybi5leGVjKHBhdGgpO1xuXG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRjb25zdCBxdWVyeSA9IGV4dHJhY3RfcXVlcnkodXJsLnNlYXJjaCk7XG5cdFx0XHRjb25zdCBwYXJ0ID0gcm91dGUucGFydHNbcm91dGUucGFydHMubGVuZ3RoIC0gMV07XG5cdFx0XHRjb25zdCBwYXJhbXMgPSBwYXJ0LnBhcmFtcyA/IHBhcnQucGFyYW1zKG1hdGNoKSA6IHt9O1xuXG5cdFx0XHRjb25zdCBwYWdlID0geyBob3N0OiBsb2NhdGlvbi5ob3N0LCBwYXRoLCBxdWVyeSwgcGFyYW1zIH07XG5cblx0XHRcdHJldHVybiB7IGhyZWY6IHVybC5ocmVmLCByb3V0ZSwgbWF0Y2gsIHBhZ2UgfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlX2Vycm9yKHVybCkge1xuXHRjb25zdCB7IGhvc3QsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IGxvY2F0aW9uO1xuXHRjb25zdCB7IHNlc3Npb24sIHByZWxvYWRlZCwgc3RhdHVzLCBlcnJvciB9ID0gaW5pdGlhbF9kYXRhO1xuXG5cdGlmICghcm9vdF9wcmVsb2FkZWQpIHtcblx0XHRyb290X3ByZWxvYWRlZCA9IHByZWxvYWRlZCAmJiBwcmVsb2FkZWRbMF07XG5cdH1cblxuXHRjb25zdCBwcm9wcyA9IHtcblx0XHRlcnJvcixcblx0XHRzdGF0dXMsXG5cdFx0c2Vzc2lvbixcblx0XHRsZXZlbDA6IHtcblx0XHRcdHByb3BzOiByb290X3ByZWxvYWRlZFxuXHRcdH0sXG5cdFx0bGV2ZWwxOiB7XG5cdFx0XHRwcm9wczoge1xuXHRcdFx0XHRzdGF0dXMsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9LFxuXHRcdFx0Y29tcG9uZW50OiBFcnJvckNvbXBvbmVudFxuXHRcdH0sXG5cdFx0c2VnbWVudHM6IHByZWxvYWRlZFxuXG5cdH07XG5cdGNvbnN0IHF1ZXJ5ID0gZXh0cmFjdF9xdWVyeShzZWFyY2gpO1xuXHRyZW5kZXIobnVsbCwgW10sIHByb3BzLCB7IGhvc3QsIHBhdGg6IHBhdGhuYW1lLCBxdWVyeSwgcGFyYW1zOiB7fSB9KTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsX3N0YXRlKCkge1xuXHRyZXR1cm4ge1xuXHRcdHg6IHBhZ2VYT2Zmc2V0LFxuXHRcdHk6IHBhZ2VZT2Zmc2V0XG5cdH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKHRhcmdldCwgaWQsIG5vc2Nyb2xsLCBoYXNoKSB7XG5cdGlmIChpZCkge1xuXHRcdC8vIHBvcHN0YXRlIG9yIGluaXRpYWwgbmF2aWdhdGlvblxuXHRcdGNpZCA9IGlkO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnN0IGN1cnJlbnRfc2Nyb2xsID0gc2Nyb2xsX3N0YXRlKCk7XG5cblx0XHQvLyBjbGlja2VkIG9uIGEgbGluay4gcHJlc2VydmUgc2Nyb2xsIHN0YXRlXG5cdFx0c2Nyb2xsX2hpc3RvcnlbY2lkXSA9IGN1cnJlbnRfc2Nyb2xsO1xuXG5cdFx0aWQgPSBjaWQgPSArK3VpZDtcblx0XHRzY3JvbGxfaGlzdG9yeVtjaWRdID0gbm9zY3JvbGwgPyBjdXJyZW50X3Njcm9sbCA6IHsgeDogMCwgeTogMCB9O1xuXHR9XG5cblx0Y2lkID0gaWQ7XG5cblx0aWYgKHJvb3RfY29tcG9uZW50KSBzdG9yZXMucHJlbG9hZGluZy5zZXQodHJ1ZSk7XG5cblx0Y29uc3QgbG9hZGVkID0gcHJlZmV0Y2hpbmcgJiYgcHJlZmV0Y2hpbmcuaHJlZiA9PT0gdGFyZ2V0LmhyZWYgP1xuXHRcdHByZWZldGNoaW5nLnByb21pc2UgOlxuXHRcdGh5ZHJhdGVfdGFyZ2V0KHRhcmdldCk7XG5cblx0cHJlZmV0Y2hpbmcgPSBudWxsO1xuXG5cdGNvbnN0IHRva2VuID0gY3VycmVudF90b2tlbiA9IHt9O1xuXHRjb25zdCB7IHJlZGlyZWN0LCBwcm9wcywgYnJhbmNoIH0gPSBhd2FpdCBsb2FkZWQ7XG5cdGlmICh0b2tlbiAhPT0gY3VycmVudF90b2tlbikgcmV0dXJuOyAvLyBhIHNlY29uZGFyeSBuYXZpZ2F0aW9uIGhhcHBlbmVkIHdoaWxlIHdlIHdlcmUgbG9hZGluZ1xuXG5cdGF3YWl0IHJlbmRlcihyZWRpcmVjdCwgYnJhbmNoLCBwcm9wcywgdGFyZ2V0LnBhZ2UpO1xuXHRpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG5cblx0aWYgKCFub3Njcm9sbCkge1xuXHRcdGxldCBzY3JvbGwgPSBzY3JvbGxfaGlzdG9yeVtpZF07XG5cblx0XHRpZiAoaGFzaCkge1xuXHRcdFx0Ly8gc2Nyb2xsIGlzIGFuIGVsZW1lbnQgaWQgKGZyb20gYSBoYXNoKSwgd2UgbmVlZCB0byBjb21wdXRlIHkuXG5cdFx0XHRjb25zdCBkZWVwX2xpbmtlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2guc2xpY2UoMSkpO1xuXG5cdFx0XHRpZiAoZGVlcF9saW5rZWQpIHtcblx0XHRcdFx0c2Nyb2xsID0ge1xuXHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0eTogZGVlcF9saW5rZWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2Nyb2xsX2hpc3RvcnlbY2lkXSA9IHNjcm9sbDtcblx0XHRpZiAoc2Nyb2xsKSBzY3JvbGxUbyhzY3JvbGwueCwgc2Nyb2xsLnkpO1xuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcihyZWRpcmVjdCwgYnJhbmNoLCBwcm9wcywgcGFnZSkge1xuXHRpZiAocmVkaXJlY3QpIHJldHVybiBnb3RvKHJlZGlyZWN0LmxvY2F0aW9uLCB7IHJlcGxhY2VTdGF0ZTogdHJ1ZSB9KTtcblxuXHRzdG9yZXMucGFnZS5zZXQocGFnZSk7XG5cdHN0b3Jlcy5wcmVsb2FkaW5nLnNldChmYWxzZSk7XG5cblx0aWYgKHJvb3RfY29tcG9uZW50KSB7XG5cdFx0cm9vdF9jb21wb25lbnQuJHNldChwcm9wcyk7XG5cdH0gZWxzZSB7XG5cdFx0cHJvcHMuc3RvcmVzID0ge1xuXHRcdFx0cGFnZTogeyBzdWJzY3JpYmU6IHN0b3Jlcy5wYWdlLnN1YnNjcmliZSB9LFxuXHRcdFx0cHJlbG9hZGluZzogeyBzdWJzY3JpYmU6IHN0b3Jlcy5wcmVsb2FkaW5nLnN1YnNjcmliZSB9LFxuXHRcdFx0c2Vzc2lvbjogc3RvcmVzLnNlc3Npb25cblx0XHR9O1xuXHRcdHByb3BzLmxldmVsMCA9IHtcblx0XHRcdHByb3BzOiBhd2FpdCByb290X3ByZWxvYWRlZFxuXHRcdH07XG5cblx0XHQvLyBmaXJzdCBsb2FkIOKAlCByZW1vdmUgU1NSJ2QgPGhlYWQ+IGNvbnRlbnRzXG5cdFx0Y29uc3Qgc3RhcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2FwcGVyLWhlYWQtc3RhcnQnKTtcblx0XHRjb25zdCBlbmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2FwcGVyLWhlYWQtZW5kJyk7XG5cblx0XHRpZiAoc3RhcnQgJiYgZW5kKSB7XG5cdFx0XHR3aGlsZSAoc3RhcnQubmV4dFNpYmxpbmcgIT09IGVuZCkgZGV0YWNoKHN0YXJ0Lm5leHRTaWJsaW5nKTtcblx0XHRcdGRldGFjaChzdGFydCk7XG5cdFx0XHRkZXRhY2goZW5kKTtcblx0XHR9XG5cblx0XHRyb290X2NvbXBvbmVudCA9IG5ldyBBcHAoe1xuXHRcdFx0dGFyZ2V0LFxuXHRcdFx0cHJvcHMsXG5cdFx0XHRoeWRyYXRlOiB0cnVlXG5cdFx0fSk7XG5cdH1cblxuXHRjdXJyZW50X2JyYW5jaCA9IGJyYW5jaDtcblx0Y3VycmVudF9xdWVyeSA9IEpTT04uc3RyaW5naWZ5KHBhZ2UucXVlcnkpO1xuXHRyZWFkeSA9IHRydWU7XG5cdHNlc3Npb25fZGlydHkgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGFydF9jaGFuZ2VkKGksIHNlZ21lbnQsIG1hdGNoLCBzdHJpbmdpZmllZF9xdWVyeSkge1xuXHQvLyBUT0RPIG9ubHkgY2hlY2sgcXVlcnkgc3RyaW5nIGNoYW5nZXMgZm9yIHByZWxvYWQgZnVuY3Rpb25zXG5cdC8vIHRoYXQgZG8gaW4gZmFjdCBkZXBlbmQgb24gaXQgKHVzaW5nIHN0YXRpYyBhbmFseXNpcyBvclxuXHQvLyBydW50aW1lIGluc3RydW1lbnRhdGlvbilcblx0aWYgKHN0cmluZ2lmaWVkX3F1ZXJ5ICE9PSBjdXJyZW50X3F1ZXJ5KSByZXR1cm4gdHJ1ZTtcblxuXHRjb25zdCBwcmV2aW91cyA9IGN1cnJlbnRfYnJhbmNoW2ldO1xuXG5cdGlmICghcHJldmlvdXMpIHJldHVybiBmYWxzZTtcblx0aWYgKHNlZ21lbnQgIT09IHByZXZpb3VzLnNlZ21lbnQpIHJldHVybiB0cnVlO1xuXHRpZiAocHJldmlvdXMubWF0Y2gpIHtcblx0XHRpZiAoSlNPTi5zdHJpbmdpZnkocHJldmlvdXMubWF0Y2guc2xpY2UoMSwgaSArIDIpKSAhPT0gSlNPTi5zdHJpbmdpZnkobWF0Y2guc2xpY2UoMSwgaSArIDIpKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGh5ZHJhdGVfdGFyZ2V0KHRhcmdldClcblxuXG5cbiB7XG5cdGNvbnN0IHsgcm91dGUsIHBhZ2UgfSA9IHRhcmdldDtcblx0Y29uc3Qgc2VnbWVudHMgPSBwYWdlLnBhdGguc3BsaXQoJy8nKS5maWx0ZXIoQm9vbGVhbik7XG5cblx0bGV0IHJlZGlyZWN0ID0gbnVsbDtcblxuXHRjb25zdCBwcm9wcyA9IHsgZXJyb3I6IG51bGwsIHN0YXR1czogMjAwLCBzZWdtZW50czogW3NlZ21lbnRzWzBdXSB9O1xuXG5cdGNvbnN0IHByZWxvYWRfY29udGV4dCA9IHtcblx0XHRmZXRjaDogKHVybCwgb3B0cykgPT4gZmV0Y2godXJsLCBvcHRzKSxcblx0XHRyZWRpcmVjdDogKHN0YXR1c0NvZGUsIGxvY2F0aW9uKSA9PiB7XG5cdFx0XHRpZiAocmVkaXJlY3QgJiYgKHJlZGlyZWN0LnN0YXR1c0NvZGUgIT09IHN0YXR1c0NvZGUgfHwgcmVkaXJlY3QubG9jYXRpb24gIT09IGxvY2F0aW9uKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYENvbmZsaWN0aW5nIHJlZGlyZWN0c2ApO1xuXHRcdFx0fVxuXHRcdFx0cmVkaXJlY3QgPSB7IHN0YXR1c0NvZGUsIGxvY2F0aW9uIH07XG5cdFx0fSxcblx0XHRlcnJvcjogKHN0YXR1cywgZXJyb3IpID0+IHtcblx0XHRcdHByb3BzLmVycm9yID0gdHlwZW9mIGVycm9yID09PSAnc3RyaW5nJyA/IG5ldyBFcnJvcihlcnJvcikgOiBlcnJvcjtcblx0XHRcdHByb3BzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR9XG5cdH07XG5cblx0aWYgKCFyb290X3ByZWxvYWRlZCkge1xuXHRcdHJvb3RfcHJlbG9hZGVkID0gaW5pdGlhbF9kYXRhLnByZWxvYWRlZFswXSB8fCByb290X3ByZWxvYWQuY2FsbChwcmVsb2FkX2NvbnRleHQsIHtcblx0XHRcdGhvc3Q6IHBhZ2UuaG9zdCxcblx0XHRcdHBhdGg6IHBhZ2UucGF0aCxcblx0XHRcdHF1ZXJ5OiBwYWdlLnF1ZXJ5LFxuXHRcdFx0cGFyYW1zOiB7fVxuXHRcdH0sICRzZXNzaW9uKTtcblx0fVxuXG5cdGxldCBicmFuY2g7XG5cdGxldCBsID0gMTtcblxuXHR0cnkge1xuXHRcdGNvbnN0IHN0cmluZ2lmaWVkX3F1ZXJ5ID0gSlNPTi5zdHJpbmdpZnkocGFnZS5xdWVyeSk7XG5cdFx0Y29uc3QgbWF0Y2ggPSByb3V0ZS5wYXR0ZXJuLmV4ZWMocGFnZS5wYXRoKTtcblxuXHRcdGxldCBzZWdtZW50X2RpcnR5ID0gZmFsc2U7XG5cblx0XHRicmFuY2ggPSBhd2FpdCBQcm9taXNlLmFsbChyb3V0ZS5wYXJ0cy5tYXAoYXN5bmMgKHBhcnQsIGkpID0+IHtcblx0XHRcdGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblxuXHRcdFx0aWYgKHBhcnRfY2hhbmdlZChpLCBzZWdtZW50LCBtYXRjaCwgc3RyaW5naWZpZWRfcXVlcnkpKSBzZWdtZW50X2RpcnR5ID0gdHJ1ZTtcblxuXHRcdFx0cHJvcHMuc2VnbWVudHNbbF0gPSBzZWdtZW50c1tpICsgMV07IC8vIFRPRE8gbWFrZSB0aGlzIGxlc3MgY29uZnVzaW5nXG5cdFx0XHRpZiAoIXBhcnQpIHJldHVybiB7IHNlZ21lbnQgfTtcblxuXHRcdFx0Y29uc3QgaiA9IGwrKztcblxuXHRcdFx0aWYgKCFzZXNzaW9uX2RpcnR5ICYmICFzZWdtZW50X2RpcnR5ICYmIGN1cnJlbnRfYnJhbmNoW2ldICYmIGN1cnJlbnRfYnJhbmNoW2ldLnBhcnQgPT09IHBhcnQuaSkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudF9icmFuY2hbaV07XG5cdFx0XHR9XG5cblx0XHRcdHNlZ21lbnRfZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0Y29uc3QgeyBkZWZhdWx0OiBjb21wb25lbnQsIHByZWxvYWQgfSA9IGF3YWl0IGxvYWRfY29tcG9uZW50KGNvbXBvbmVudHNbcGFydC5pXSk7XG5cblx0XHRcdGxldCBwcmVsb2FkZWQ7XG5cdFx0XHRpZiAocmVhZHkgfHwgIWluaXRpYWxfZGF0YS5wcmVsb2FkZWRbaSArIDFdKSB7XG5cdFx0XHRcdHByZWxvYWRlZCA9IHByZWxvYWRcblx0XHRcdFx0XHQ/IGF3YWl0IHByZWxvYWQuY2FsbChwcmVsb2FkX2NvbnRleHQsIHtcblx0XHRcdFx0XHRcdGhvc3Q6IHBhZ2UuaG9zdCxcblx0XHRcdFx0XHRcdHBhdGg6IHBhZ2UucGF0aCxcblx0XHRcdFx0XHRcdHF1ZXJ5OiBwYWdlLnF1ZXJ5LFxuXHRcdFx0XHRcdFx0cGFyYW1zOiBwYXJ0LnBhcmFtcyA/IHBhcnQucGFyYW1zKHRhcmdldC5tYXRjaCkgOiB7fVxuXHRcdFx0XHRcdH0sICRzZXNzaW9uKVxuXHRcdFx0XHRcdDoge307XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcmVsb2FkZWQgPSBpbml0aWFsX2RhdGEucHJlbG9hZGVkW2kgKyAxXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChwcm9wc1tgbGV2ZWwke2p9YF0gPSB7IGNvbXBvbmVudCwgcHJvcHM6IHByZWxvYWRlZCwgc2VnbWVudCwgbWF0Y2gsIHBhcnQ6IHBhcnQuaSB9KTtcblx0XHR9KSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cHJvcHMuZXJyb3IgPSBlcnJvcjtcblx0XHRwcm9wcy5zdGF0dXMgPSA1MDA7XG5cdFx0YnJhbmNoID0gW107XG5cdH1cblxuXHRyZXR1cm4geyByZWRpcmVjdCwgcHJvcHMsIGJyYW5jaCB9O1xufVxuXG5mdW5jdGlvbiBsb2FkX2NzcyhjaHVuaykge1xuXHRjb25zdCBocmVmID0gYGNsaWVudC8ke2NodW5rfWA7XG5cdGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsaW5rW2hyZWY9XCIke2hyZWZ9XCJdYCkpIHJldHVybjtcblxuXHRyZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbCwgcmVqZWN0KSA9PiB7XG5cdFx0Y29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblx0XHRsaW5rLnJlbCA9ICdzdHlsZXNoZWV0Jztcblx0XHRsaW5rLmhyZWYgPSBocmVmO1xuXG5cdFx0bGluay5vbmxvYWQgPSAoKSA9PiBmdWxmaWwoKTtcblx0XHRsaW5rLm9uZXJyb3IgPSByZWplY3Q7XG5cblx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gbG9hZF9jb21wb25lbnQoY29tcG9uZW50KVxuXG5cbiB7XG5cdC8vIFRPRE8gdGhpcyBpcyB0ZW1wb3Jhcnkg4oCUIG9uY2UgcGxhY2Vob2xkZXJzIGFyZVxuXHQvLyBhbHdheXMgcmV3cml0dGVuLCBzY3JhdGNoIHRoZSB0ZXJuYXJ5XG5cdGNvbnN0IHByb21pc2VzID0gKHR5cGVvZiBjb21wb25lbnQuY3NzID09PSAnc3RyaW5nJyA/IFtdIDogY29tcG9uZW50LmNzcy5tYXAobG9hZF9jc3MpKTtcblx0cHJvbWlzZXMudW5zaGlmdChjb21wb25lbnQuanMoKSk7XG5cdHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbih2YWx1ZXMgPT4gdmFsdWVzWzBdKTtcbn1cblxuZnVuY3Rpb24gZGV0YWNoKG5vZGUpIHtcblx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBwcmVmZXRjaChocmVmKSB7XG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQobmV3IFVSTChocmVmLCBkb2N1bWVudC5iYXNlVVJJKSk7XG5cblx0aWYgKHRhcmdldCkge1xuXHRcdGlmICghcHJlZmV0Y2hpbmcgfHwgaHJlZiAhPT0gcHJlZmV0Y2hpbmcuaHJlZikge1xuXHRcdFx0c2V0X3ByZWZldGNoaW5nKGhyZWYsIGh5ZHJhdGVfdGFyZ2V0KHRhcmdldCkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmVmZXRjaGluZy5wcm9taXNlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0KG9wdHNcblxuKSB7XG5cdGlmICgnc2Nyb2xsUmVzdG9yYXRpb24nIGluIF9oaXN0b3J5KSB7XG5cdFx0X2hpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcblx0fVxuXG5cdHNldF90YXJnZXQob3B0cy50YXJnZXQpO1xuXG5cdGFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlX2NsaWNrKTtcblx0YWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBoYW5kbGVfcG9wc3RhdGUpO1xuXG5cdC8vIHByZWZldGNoXG5cdGFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0cmlnZ2VyX3ByZWZldGNoKTtcblx0YWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlX21vdXNlbW92ZSk7XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdGNvbnN0IHsgaGFzaCwgaHJlZiB9ID0gbG9jYXRpb247XG5cblx0XHRfaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBpZDogdWlkIH0sICcnLCBocmVmKTtcblxuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwobG9jYXRpb24uaHJlZik7XG5cblx0XHRpZiAoaW5pdGlhbF9kYXRhLmVycm9yKSByZXR1cm4gaGFuZGxlX2Vycm9yKCk7XG5cblx0XHRjb25zdCB0YXJnZXQgPSBzZWxlY3RfdGFyZ2V0KHVybCk7XG5cdFx0aWYgKHRhcmdldCkgcmV0dXJuIG5hdmlnYXRlKHRhcmdldCwgdWlkLCB0cnVlLCBoYXNoKTtcblx0fSk7XG59XG5cbmxldCBtb3VzZW1vdmVfdGltZW91dDtcblxuZnVuY3Rpb24gaGFuZGxlX21vdXNlbW92ZShldmVudCkge1xuXHRjbGVhclRpbWVvdXQobW91c2Vtb3ZlX3RpbWVvdXQpO1xuXHRtb3VzZW1vdmVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdHRyaWdnZXJfcHJlZmV0Y2goZXZlbnQpO1xuXHR9LCAyMCk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJfcHJlZmV0Y2goZXZlbnQpIHtcblx0Y29uc3QgYSA9IGZpbmRfYW5jaG9yKGV2ZW50LnRhcmdldCk7XG5cdGlmICghYSB8fCBhLnJlbCAhPT0gJ3ByZWZldGNoJykgcmV0dXJuO1xuXG5cdHByZWZldGNoKGEuaHJlZik7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZV9jbGljayhldmVudCkge1xuXHQvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Zpc2lvbm1lZGlhL3BhZ2UuanNcblx0Ly8gTUlUIGxpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL3Zpc2lvbm1lZGlhL3BhZ2UuanMjbGljZW5zZVxuXHRpZiAod2hpY2goZXZlbnQpICE9PSAxKSByZXR1cm47XG5cdGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHJldHVybjtcblx0aWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuXHRjb25zdCBhID0gZmluZF9hbmNob3IoZXZlbnQudGFyZ2V0KTtcblx0aWYgKCFhKSByZXR1cm47XG5cblx0aWYgKCFhLmhyZWYpIHJldHVybjtcblxuXHQvLyBjaGVjayBpZiBsaW5rIGlzIGluc2lkZSBhbiBzdmdcblx0Ly8gaW4gdGhpcyBjYXNlLCBib3RoIGhyZWYgYW5kIHRhcmdldCBhcmUgYWx3YXlzIGluc2lkZSBhbiBvYmplY3Rcblx0Y29uc3Qgc3ZnID0gdHlwZW9mIGEuaHJlZiA9PT0gJ29iamVjdCcgJiYgYS5ocmVmLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTVkdBbmltYXRlZFN0cmluZyc7XG5cdGNvbnN0IGhyZWYgPSBTdHJpbmcoc3ZnID8gKGEpLmhyZWYuYmFzZVZhbCA6IGEuaHJlZik7XG5cblx0aWYgKGhyZWYgPT09IGxvY2F0aW9uLmhyZWYpIHtcblx0XHRpZiAoIWxvY2F0aW9uLmhhc2gpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gSWdub3JlIGlmIHRhZyBoYXNcblx0Ly8gMS4gJ2Rvd25sb2FkJyBhdHRyaWJ1dGVcblx0Ly8gMi4gcmVsPSdleHRlcm5hbCcgYXR0cmlidXRlXG5cdGlmIChhLmhhc0F0dHJpYnV0ZSgnZG93bmxvYWQnKSB8fCBhLmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdleHRlcm5hbCcpIHJldHVybjtcblxuXHQvLyBJZ25vcmUgaWYgPGE+IGhhcyBhIHRhcmdldFxuXHRpZiAoc3ZnID8gKGEpLnRhcmdldC5iYXNlVmFsIDogYS50YXJnZXQpIHJldHVybjtcblxuXHRjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpO1xuXG5cdC8vIERvbid0IGhhbmRsZSBoYXNoIGNoYW5nZXNcblx0aWYgKHVybC5wYXRobmFtZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgJiYgdXJsLnNlYXJjaCA9PT0gbG9jYXRpb24uc2VhcmNoKSByZXR1cm47XG5cblx0Y29uc3QgdGFyZ2V0ID0gc2VsZWN0X3RhcmdldCh1cmwpO1xuXHRpZiAodGFyZ2V0KSB7XG5cdFx0Y29uc3Qgbm9zY3JvbGwgPSBhLmhhc0F0dHJpYnV0ZSgnc2FwcGVyLW5vc2Nyb2xsJyk7XG5cdFx0bmF2aWdhdGUodGFyZ2V0LCBudWxsLCBub3Njcm9sbCwgdXJsLmhhc2gpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0X2hpc3RvcnkucHVzaFN0YXRlKHsgaWQ6IGNpZCB9LCAnJywgdXJsLmhyZWYpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHdoaWNoKGV2ZW50KSB7XG5cdHJldHVybiBldmVudC53aGljaCA9PT0gbnVsbCA/IGV2ZW50LmJ1dHRvbiA6IGV2ZW50LndoaWNoO1xufVxuXG5mdW5jdGlvbiBmaW5kX2FuY2hvcihub2RlKSB7XG5cdHdoaWxlIChub2RlICYmIG5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0EnKSBub2RlID0gbm9kZS5wYXJlbnROb2RlOyAvLyBTVkcgPGE+IGVsZW1lbnRzIGhhdmUgYSBsb3dlcmNhc2UgbmFtZVxuXHRyZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3BvcHN0YXRlKGV2ZW50KSB7XG5cdHNjcm9sbF9oaXN0b3J5W2NpZF0gPSBzY3JvbGxfc3RhdGUoKTtcblxuXHRpZiAoZXZlbnQuc3RhdGUpIHtcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xuXHRcdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQodXJsKTtcblx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRuYXZpZ2F0ZSh0YXJnZXQsIGV2ZW50LnN0YXRlLmlkKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9jYXRpb24uaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGhhc2hjaGFuZ2Vcblx0XHRzZXRfdWlkKHVpZCArIDEpO1xuXHRcdHNldF9jaWQodWlkKTtcblx0XHRfaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBpZDogY2lkIH0sICcnLCBsb2NhdGlvbi5ocmVmKTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcmVmZXRjaFJvdXRlcyhwYXRobmFtZXMpIHtcblx0cmV0dXJuIHJvdXRlc1xuXHRcdC5maWx0ZXIocGF0aG5hbWVzXG5cdFx0XHQ/IHJvdXRlID0+IHBhdGhuYW1lcy5zb21lKHBhdGhuYW1lID0+IHJvdXRlLnBhdHRlcm4udGVzdChwYXRobmFtZSkpXG5cdFx0XHQ6ICgpID0+IHRydWVcblx0XHQpXG5cdFx0LnJlZHVjZSgocHJvbWlzZSwgcm91dGUpID0+IHByb21pc2UudGhlbigoKSA9PiB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwocm91dGUucGFydHMubWFwKHBhcnQgPT4gcGFydCAmJiBsb2FkX2NvbXBvbmVudChjb21wb25lbnRzW3BhcnQuaV0pKSk7XG5cdFx0fSksIFByb21pc2UucmVzb2x2ZSgpKTtcbn1cblxuY29uc3Qgc3RvcmVzJDEgPSAoKSA9PiBnZXRDb250ZXh0KENPTlRFWFRfS0VZKTtcblxuZXhwb3J0IHsgZ290bywgcHJlZmV0Y2gsIHByZWZldGNoUm91dGVzLCBzdGFydCwgc3RvcmVzJDEgYXMgc3RvcmVzIH07XG4iLCJpbXBvcnQgKiBhcyBzYXBwZXIgZnJvbSAnQHNhcHBlci9hcHAnO1xuXG5zYXBwZXIuc3RhcnQoe1xuXHR0YXJnZXQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXBwZXInKVxufSk7Il0sIm5hbWVzIjpbIkVycm9yQ29tcG9uZW50Iiwicm9vdF9wcmVsb2FkIiwic2FwcGVyLnN0YXJ0Il0sIm1hcHBpbmdzIjoiOzs7QUFHQSxNQUFNLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztBQUM1QixBQVVBOzs7OztBQUtBLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRSxLQUFLLEdBQUcsSUFBSSxFQUFFO0lBQ25DLElBQUksSUFBSSxDQUFDO0lBQ1QsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO0lBQ3ZCLFNBQVMsR0FBRyxDQUFDLFNBQVMsRUFBRTtRQUNwQixJQUFJLGNBQWMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLEVBQUU7WUFDbEMsS0FBSyxHQUFHLFNBQVMsQ0FBQztZQUNsQixJQUFJLElBQUksRUFBRTtnQkFDTixNQUFNLFNBQVMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztnQkFDM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDNUMsTUFBTSxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztvQkFDUCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2lCQUNuQztnQkFDRCxJQUFJLFNBQVMsRUFBRTtvQkFDWCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7d0JBQ2pELGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxD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
